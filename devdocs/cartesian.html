<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documenter.jl</title><link href="../normalize.css" rel="stylesheet" type="text/css"/><link href="../style.css" rel="stylesheet" type="text/css"/><link href="../highlight.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="../require.js" data-main="../documenter.js"></script><script src="../search-index.js"></script></head><body><nav class="toc"><a href="http://julialang.org/"><img class="logo" src="http://docs.julialang.org/en/release-0.4/_static/julia-logo.svg" alt="\$pkgname.jl logo"/></a><h1>$pkgname.jl</h1><input type="text" placeholder="Search docs"/><ul><li><a class="toctext" href="../index.html">Overview</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/guide.html">Guide</a></li><li><a class="toctext" href="../man/examples.html">Examples</a></li><li><a class="toctext" href="../man/syntax.html">Syntax</a></li><li><a class="toctext" href="../man/doctests.html">Doctests</a></li><li><a class="toctext" href="../man/hosting.html">Hosting Documentation</a></li><li><a class="toctext" href="../man/latex.html"><span>$\LaTeX$</span> syntax</a></li><li><a class="toctext" href="../man/internals.html">Package Internals</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../lib/public.html">Public Documentation</a></li><li><a class="toctext" href="../lib/internals.html">Internal Documentation</a></li></ul></li><li><span class="toctext">Dynamic pages</span><ul><li><a class="toctext" href="../dynamic/code.html">Code examples</a></li><li><a class="toctext" href="../dynamic/admonitions.html">Admonitions &amp; Co</a></li><li><a class="toctext" href="../dynamic/styles.html">Demonstrating <em>styles</em> of MD elements</a></li><li><a class="toctext" href="../dynamic/bugs.html">Some existing bugs</a></li></ul></li><li><span class="toctext">JuliaDocs - Manual</span><ul><li><a class="toctext" href="../manual/arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../manual/calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="../manual/complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="../manual/constructors.html">Constructors</a></li><li><a class="toctext" href="../manual/control-flow.html">Control Flow</a></li><li><a class="toctext" href="../manual/conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="../manual/dates.html">Date and DateTime</a></li><li><a class="toctext" href="../manual/documentation.html">Documentation</a></li><li><a class="toctext" href="../manual/embedding.html">Embedding Julia</a></li><li><a class="toctext" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="../manual/functions.html">Functions</a></li><li><a class="toctext" href="../manual/getting-started.html">Getting Started</a></li><li><a class="toctext" href="../manual/handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="../manual/index.html">The Julia Manual</a></li><li><a class="toctext" href="../manual/integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../manual/interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="../manual/interfaces.html">Interfaces</a></li><li><a class="toctext" href="../manual/introduction.html">Introduction</a></li><li><a class="toctext" href="../manual/linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="../manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../manual/metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="../manual/methods.html">Methods</a></li><li><a class="toctext" href="../manual/modules.html">Modules</a></li><li><a class="toctext" href="../manual/networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="../manual/noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../manual/packages.html">Packages</a></li><li><a class="toctext" href="../manual/parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="../manual/performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="../manual/profile.html">Profiling</a></li><li><a class="toctext" href="../manual/running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="../manual/stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="../manual/strings.html">Strings</a></li><li><a class="toctext" href="../manual/style-guide.html">Style Guide</a></li><li><a class="toctext" href="../manual/types.html">Types</a></li><li><a class="toctext" href="../manual/unicode-input.html">Unicode Input</a></li><li><a class="toctext" href="../manual/variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="../manual/variables.html">Variables</a></li><li><a class="toctext" href="../manual/workflow-tips.html">Workflow Tips</a></li></ul></li><li><span class="toctext">JuliaDocs - Standard Libary</span><ul><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/c.html">C Interface</a></li><li><a class="toctext" href="../stdlib/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../stdlib/constants.html">Constants</a></li><li><a class="toctext" href="../stdlib/dates.html">Dates and Time</a></li><li><a class="toctext" href="../stdlib/file.html">Filesystem</a></li><li><a class="toctext" href="../stdlib/index.html">The Julia Standard Library</a></li><li><a class="toctext" href="../stdlib/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../stdlib/libc.html">C Standard Library</a></li><li><a class="toctext" href="../stdlib/libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/linalg.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/math.html">Mathematics</a></li><li><a class="toctext" href="../stdlib/numbers.html">Numbers</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="../stdlib/pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../stdlib/simd-types.html">SIMD Support</a></li><li><a class="toctext" href="../stdlib/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../stdlib/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../stdlib/strings.html">Strings</a></li><li><a class="toctext" href="../stdlib/test.html">Unit Testing</a></li></ul></li><li><span class="toctext">JuliaDocs - DevDocs</span><ul><li><a class="toctext" href="ast.html">Julia ASTs</a></li><li><a class="toctext" href="backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="callconv.html">Calling Conventions</a></li><li class="current"><a class="toctext" href="cartesian.html">Base.Cartesian</a><ul class="internal"><li><a class="toctext" href="#Principles-of-usage-1">Principles of usage</a></li><li><a class="toctext" href="#Basic-syntax-1">Basic syntax</a></li></ul></li><li><a class="toctext" href="C.html">Developing/debugging Julia&#39;s C code</a></li><li><a class="toctext" href="debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="eval.html">Eval of Julia code</a></li><li><a class="toctext" href="functions.html">Julia Functions</a></li><li><a class="toctext" href="init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="julia.html">Documentation of Julia&#39;s Internals</a></li><li><a class="toctext" href="llvm.html">Working with LLVM</a></li><li><a class="toctext" href="locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="promote-op.html">Operator-sensitive promotion</a></li><li><a class="toctext" href="reflection.html">Reflection and introspection</a></li><li><a class="toctext" href="stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="subarrays.html">SubArrays</a></li><li><a class="toctext" href="sysimg.html">System Image Building</a></li><li><a class="toctext" href="types.html">More about types</a></li><li><a class="toctext" href="valgrind.html">Using Valgrind with Julia</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>JuliaDocs - DevDocs</li><li><a href="cartesian.html">Base.Cartesian</a></li></ul><a class="edit-page" href="https://github.com/"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><a id="Base.Cartesian-1"></a><div class="mdnote debug">Base.Markdown.Header{1}</div><h1>Base.Cartesian</h1><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The (non-exported) Cartesian module provides macros that facilitate writing multidimensional algorithms. It is hoped that Cartesian will not, in the long term, be necessary; however, at present it is one of the few ways to write compact and performant multidimensional code.</p><a id="Principles-of-usage-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Principles of usage</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A simple example of usage is:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="p">@</span><span class="n">nloops</span><span> </span><span class="mi">3</span><span> </span><span class="n">i</span><span> </span><span class="n">A</span><span> </span><span class="k">begin</span><span>
</span><span>    </span><span class="n">s</span><span> </span><span class="o">+</span><span class="o">=</span><span> </span><span class="p">@</span><span class="n">nref</span><span> </span><span class="mi">3</span><span> </span><span class="n">A</span><span> </span><span class="n">i</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>which generates the following code:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">for</span><span> </span><span class="n">i_3</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span class="p">:</span><span class="n">size</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span>
</span><span>    </span><span class="k">for</span><span> </span><span class="n">i_2</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span class="p">:</span><span class="n">size</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span>
</span><span>        </span><span class="k">for</span><span> </span><span class="n">i_1</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span class="p">:</span><span class="n">size</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span>
</span><span>            </span><span class="n">s</span><span> </span><span class="o">+</span><span class="o">=</span><span> </span><span class="n">A</span><span class="p">[</span><span class="n">i_1</span><span class="p">,</span><span class="n">i_2</span><span class="p">,</span><span class="n">i_3</span><span class="p">]</span><span>
</span><span>        </span><span class="k">end</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In general, Cartesian allows you to write generic code that contains repetitive elements, like the nested loops in this example.  Other applications include repeated expressions (e.g., loop unwinding) or creating function calls with variable numbers of arguments without using the &quot;splat&quot; construct (<code>i...</code>).</p><a id="Basic-syntax-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Basic syntax</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The (basic) syntax of <code>@nloops</code> is as follows:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>The first argument must be an integer (<em>not</em> a variable) specifying the number of loops.</p></li><li><p>The second argument is the symbol-prefix used for the iterator variable. Here we used <code>i</code>, and variables <code>i_1, i_2, i_3</code> were generated.</p></li><li><p>The third argument specifies the range for each iterator variable. If you use a variable (symbol) here, it&#39;s taken as <code>1:size(A,dim)</code>. More flexibly, you can use the anonymous-function expression syntax described below.</p></li><li><p>The last argument is the body of the loop. Here, that&#39;s what appears between the <code>begin...end</code>.</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>There are some additional features of <code>@nloops</code> described in the <a href="@ref">reference section</a>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p><code>@nref</code> follows a similar pattern, generating <code>A[i_1,i_2,i_3]</code> from <code>@nref 3 A i</code>. The general practice is to read from left to right, which is why <code>@nloops</code> is <code>@nloops 3 i A expr</code> (as in <code>for i_2 = 1:size(A,2)</code>, where <code>i_2</code> is to the left and the range is to the right) whereas <code>@nref</code> is <code>@nref 3 A i</code> (as in <code>A[i_1,i_2,i_3]</code>, where the array comes first).</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If you&#39;re developing code with Cartesian, you may find that debugging is easier when you examine the generated code, using <code>macroexpand</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">macroexpand</span><span class="p">(</span><span class="p">:</span><span class="p">(</span><span class="p">@</span><span class="n">nref</span><span> </span><span class="mi">2</span><span> </span><span class="n">A</span><span> </span><span class="n">i</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">:(A[i_1,i_2])
</span></code></pre><a id="Supplying-the-number-of-expressions-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Supplying the number of expressions</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The first argument to both of these macros is the number of expressions, which must be an integer. When you&#39;re writing a function that you intend to work in multiple dimensions, this may not be something you want to hard-code. If you&#39;re writing code that you need to work with older Julia versions, currently you should use the <code>@ngenerate</code> macro described in <a href="http://docs.julialang.org/en/release-0.3/devdocs/cartesian/#supplying-the-number-of-expressions">an older version of this documentation</a>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Starting in Julia 0.4-pre, the recommended approach is to use a <code>@generated function</code>.  Here&#39;s an example:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="p">@</span><span class="n">generated</span><span> </span><span class="k">function</span><span class="nf"> </span><span class="nf">mysum</span><span class="p">{</span><span class="n">T</span><span class="p">,</span><span class="n">N</span><span class="p">}</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="p">:</span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">,</span><span class="n">N</span><span class="p">}</span><span class="p">)</span><span>
</span><span>    </span><span class="k">quote</span><span>
</span><span>        </span><span class="n">s</span><span> </span><span class="o">=</span><span> </span><span class="n">zero</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span>
</span><span>        </span><span class="p">@</span><span class="n">nloops</span><span> </span><span class="o">$</span><span class="n">N</span><span> </span><span class="n">i</span><span> </span><span class="n">A</span><span> </span><span class="k">begin</span><span>
</span><span>            </span><span class="n">s</span><span> </span><span class="o">+</span><span class="o">=</span><span> </span><span class="p">@</span><span class="n">nref</span><span> </span><span class="o">$</span><span class="n">N</span><span> </span><span class="n">A</span><span> </span><span class="n">i</span><span>
</span><span>        </span><span class="k">end</span><span>
</span><span>        </span><span class="n">s</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Naturally, you can also prepare expressions or perform calculations before the <code>quote</code> block.</p><a id="Anonymous-function-expressions-as-macro-arguments-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Anonymous-function expressions as macro arguments</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Perhaps the single most powerful feature in <code>Cartesian</code> is the ability to supply anonymous-function expressions that get evaluated at parsing time.  Let&#39;s consider a simple example:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="p">@</span><span class="n">nexprs</span><span> </span><span class="mi">2</span><span> </span><span class="n">j</span><span class="o">-&gt;</span><span class="p">(</span><span class="n">i_j</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p><code>@nexprs</code> generates <code>n</code> expressions that follow a pattern. This code would generate the following statements:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">i_1</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span>
</span><span class="n">i_2</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In each generated statement, an &quot;isolated&quot; <code>j</code> (the variable of the anonymous function) gets replaced by values in the range <code>1:2</code>. Generally speaking, Cartesian employs a LaTeX-like syntax.  This allows you to do math on the index <code>j</code>.  Here&#39;s an example computing the strides of an array:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">s_1</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span>
</span><span class="p">@</span><span class="n">nexprs</span><span> </span><span class="mi">3</span><span> </span><span class="n">j</span><span class="o">-&gt;</span><span class="p">(</span><span class="n">s_</span><span class="p">{</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">}</span><span> </span><span class="o">=</span><span> </span><span class="n">s_j</span><span> </span><span class="o">*</span><span> </span><span class="n">size</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span> </span><span class="n">j</span><span class="p">)</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>would generate expressions</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">s_1</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span>
</span><span class="n">s_2</span><span> </span><span class="o">=</span><span> </span><span class="n">s_1</span><span> </span><span class="o">*</span><span> </span><span class="n">size</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span> </span><span class="mi">1</span><span class="p">)</span><span>
</span><span class="n">s_3</span><span> </span><span class="o">=</span><span> </span><span class="n">s_2</span><span> </span><span class="o">*</span><span> </span><span class="n">size</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span> </span><span class="mi">2</span><span class="p">)</span><span>
</span><span class="n">s_4</span><span> </span><span class="o">=</span><span> </span><span class="n">s_3</span><span> </span><span class="o">*</span><span> </span><span class="n">size</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span> </span><span class="mi">3</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Anonymous-function expressions have many uses in practice.</p><a id="Macro-reference-1"></a><div class="mdnote debug">Base.Markdown.Header{4}</div><h4>Macro reference</h4><section class="docstring"><div class="docheader"><a id="Base.Cartesian.@nloops" href="#Base.Cartesian.@nloops">#</a> <strong><code>Base.Cartesian.@nloops</code></strong> — <em>Macro</em>.</div><strong>Methods</strong>This function has no methods to display.<em>Hiding 1 method defined outside of this package.</em></section><section class="docstring"><div class="docheader"><a id="Base.Cartesian.@nref" href="#Base.Cartesian.@nref">#</a> <strong><code>Base.Cartesian.@nref</code></strong> — <em>Macro</em>.</div><strong>Methods</strong>This function has no methods to display.<em>Hiding 1 method defined outside of this package.</em></section><section class="docstring"><div class="docheader"><a id="Base.Cartesian.@nextract" href="#Base.Cartesian.@nextract">#</a> <strong><code>Base.Cartesian.@nextract</code></strong> — <em>Macro</em>.</div><strong>Methods</strong>This function has no methods to display.<em>Hiding 1 method defined outside of this package.</em></section><section class="docstring"><div class="docheader"><a id="Base.Cartesian.@nexprs" href="#Base.Cartesian.@nexprs">#</a> <strong><code>Base.Cartesian.@nexprs</code></strong> — <em>Macro</em>.</div><strong>Methods</strong>This function has no methods to display.<em>Hiding 1 method defined outside of this package.</em></section><section class="docstring"><div class="docheader"><a id="Base.Cartesian.@ncall" href="#Base.Cartesian.@ncall">#</a> <strong><code>Base.Cartesian.@ncall</code></strong> — <em>Macro</em>.</div><strong>Methods</strong>This function has no methods to display.<em>Hiding 1 method defined outside of this package.</em></section><section class="docstring"><div class="docheader"><a id="Base.Cartesian.@ntuple" href="#Base.Cartesian.@ntuple">#</a> <strong><code>Base.Cartesian.@ntuple</code></strong> — <em>Macro</em>.</div><strong>Methods</strong>This function has no methods to display.<em>Hiding 1 method defined outside of this package.</em></section><section class="docstring"><div class="docheader"><a id="Base.Cartesian.@nall" href="#Base.Cartesian.@nall">#</a> <strong><code>Base.Cartesian.@nall</code></strong> — <em>Macro</em>.</div><strong>Methods</strong>This function has no methods to display.<em>Hiding 1 method defined outside of this package.</em></section><section class="docstring"><div class="docheader"><a id="Base.Cartesian.@nany" href="#Base.Cartesian.@nany">#</a> <strong><code>Base.Cartesian.@nany</code></strong> — <em>Macro</em>.</div><strong>Methods</strong>This function has no methods to display.<em>Hiding 1 method defined outside of this package.</em></section><section class="docstring"><div class="docheader"><a id="Base.Cartesian.@nif" href="#Base.Cartesian.@nif">#</a> <strong><code>Base.Cartesian.@nif</code></strong> — <em>Macro</em>.</div><strong>Methods</strong>This function has no methods to display.<em>Hiding 1 method defined outside of this package.</em></section><footer><hr/><a class="previous" href="callconv.html"><span class="direction">Previous</span><span class="title">Calling Conventions</span></a><a class="next" href="C.html"><span class="direction">Next</span><span class="title">Developing/debugging Julia&#39;s C code</span></a></footer></article></body></html>
