<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documenter.jl</title><link href="../normalize.css" rel="stylesheet" type="text/css"/><link href="../style.css" rel="stylesheet" type="text/css"/><link href="../highlight.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="../require.js" data-main="../documenter.js"></script><script src="../search-index.js"></script></head><body><nav class="toc"><a href="http://julialang.org/"><img class="logo" src="http://docs.julialang.org/en/release-0.4/_static/julia-logo.svg" alt="\$pkgname.jl logo"/></a><h1>$pkgname.jl</h1><input type="text" placeholder="Search docs"/><ul><li><a class="toctext" href="../index.html">Overview</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/guide.html">Guide</a></li><li><a class="toctext" href="../man/examples.html">Examples</a></li><li><a class="toctext" href="../man/syntax.html">Syntax</a></li><li><a class="toctext" href="../man/doctests.html">Doctests</a></li><li><a class="toctext" href="../man/hosting.html">Hosting Documentation</a></li><li><a class="toctext" href="../man/latex.html"><span>$\LaTeX$</span> syntax</a></li><li><a class="toctext" href="../man/internals.html">Package Internals</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../lib/public.html">Public Documentation</a></li><li><a class="toctext" href="../lib/internals.html">Internal Documentation</a></li></ul></li><li><span class="toctext">Dynamic pages</span><ul><li><a class="toctext" href="../dynamic/code.html">Code examples</a></li><li><a class="toctext" href="../dynamic/admonitions.html">Admonitions &amp; Co</a></li><li><a class="toctext" href="../dynamic/styles.html">Demonstrating <em>styles</em> of MD elements</a></li><li><a class="toctext" href="../dynamic/bugs.html">Some existing bugs</a></li></ul></li><li><span class="toctext">JuliaDocs - Manual</span><ul><li><a class="toctext" href="../manual/arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../manual/calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="../manual/complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="../manual/constructors.html">Constructors</a></li><li><a class="toctext" href="../manual/control-flow.html">Control Flow</a></li><li><a class="toctext" href="../manual/conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="../manual/dates.html">Date and DateTime</a></li><li><a class="toctext" href="../manual/documentation.html">Documentation</a></li><li><a class="toctext" href="../manual/embedding.html">Embedding Julia</a></li><li><a class="toctext" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="../manual/functions.html">Functions</a></li><li><a class="toctext" href="../manual/getting-started.html">Getting Started</a></li><li><a class="toctext" href="../manual/handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="../manual/index.html">The Julia Manual</a></li><li><a class="toctext" href="../manual/integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../manual/interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="../manual/interfaces.html">Interfaces</a></li><li><a class="toctext" href="../manual/introduction.html">Introduction</a></li><li><a class="toctext" href="../manual/linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="../manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../manual/metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="../manual/methods.html">Methods</a></li><li><a class="toctext" href="../manual/modules.html">Modules</a></li><li><a class="toctext" href="../manual/networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="../manual/noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../manual/packages.html">Packages</a></li><li><a class="toctext" href="../manual/parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="../manual/performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="../manual/profile.html">Profiling</a></li><li><a class="toctext" href="../manual/running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="../manual/stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="../manual/strings.html">Strings</a></li><li><a class="toctext" href="../manual/style-guide.html">Style Guide</a></li><li><a class="toctext" href="../manual/types.html">Types</a></li><li><a class="toctext" href="../manual/unicode-input.html">Unicode Input</a></li><li><a class="toctext" href="../manual/variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="../manual/variables.html">Variables</a></li><li><a class="toctext" href="../manual/workflow-tips.html">Workflow Tips</a></li></ul></li><li><span class="toctext">JuliaDocs - Standard Libary</span><ul><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/c.html">C Interface</a></li><li><a class="toctext" href="../stdlib/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../stdlib/constants.html">Constants</a></li><li><a class="toctext" href="../stdlib/dates.html">Dates and Time</a></li><li><a class="toctext" href="../stdlib/file.html">Filesystem</a></li><li><a class="toctext" href="../stdlib/index.html">The Julia Standard Library</a></li><li><a class="toctext" href="../stdlib/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../stdlib/libc.html">C Standard Library</a></li><li><a class="toctext" href="../stdlib/libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/linalg.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/math.html">Mathematics</a></li><li><a class="toctext" href="../stdlib/numbers.html">Numbers</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="../stdlib/pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../stdlib/simd-types.html">SIMD Support</a></li><li><a class="toctext" href="../stdlib/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../stdlib/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../stdlib/strings.html">Strings</a></li><li><a class="toctext" href="../stdlib/test.html">Unit Testing</a></li></ul></li><li><span class="toctext">JuliaDocs - DevDocs</span><ul><li><a class="toctext" href="ast.html">Julia ASTs</a></li><li><a class="toctext" href="backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="callconv.html">Calling Conventions</a></li><li><a class="toctext" href="cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="C.html">Developing/debugging Julia&#39;s C code</a></li><li><a class="toctext" href="debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="eval.html">Eval of Julia code</a></li><li><a class="toctext" href="functions.html">Julia Functions</a></li><li><a class="toctext" href="init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="julia.html">Documentation of Julia&#39;s Internals</a></li><li><a class="toctext" href="llvm.html">Working with LLVM</a></li><li><a class="toctext" href="locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="promote-op.html">Operator-sensitive promotion</a></li><li><a class="toctext" href="reflection.html">Reflection and introspection</a></li><li><a class="toctext" href="stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="subarrays.html">SubArrays</a></li><li><a class="toctext" href="sysimg.html">System Image Building</a></li><li class="current"><a class="toctext" href="types.html">More about types</a><ul class="internal"><li><a class="toctext" href="#Types-and-sets-(and-Any-and-Union{}/Bottom)-1">Types and sets (and <code>Any</code> and <code>Union{}</code>/<code>Bottom</code>)</a></li><li><a class="toctext" href="#TypeVars-1">TypeVars</a></li><li><a class="toctext" href="#TypeNames-1">TypeNames</a></li><li><a class="toctext" href="#Tuple-types-1">Tuple-types</a></li><li><a class="toctext" href="#Introduction-to-the-internal-machinery:-jltypes.c-1">Introduction to the internal machinery: <code>jltypes.c</code></a></li><li><a class="toctext" href="#Subtyping-and-method-sorting-1">Subtyping and method sorting</a></li></ul></li><li><a class="toctext" href="valgrind.html">Using Valgrind with Julia</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>JuliaDocs - DevDocs</li><li><a href="types.html">More about types</a></li></ul><a class="edit-page" href="https://github.com/"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><a id="More-about-types-1"></a><div class="mdnote debug">Base.Markdown.Header{1}</div><h1>More about types</h1><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If you&#39;ve used Julia for a while, you understand the fundamental role that types play.  Here we try to get under the hood, focusing particularly on <a href="@ref">parametric types</a>.</p><a id="Types-and-sets-(and-Any-and-Union{}/Bottom)-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Types and sets (and <code>Any</code> and <code>Union{}</code>/<code>Bottom</code>)</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>It&#39;s perhaps easiest to conceive of Julia&#39;s type system in terms of sets.  A concrete type corresponds to a single entity in the space of all possible types; an abstract type refers to a collection (set) of concrete types.  <code>Any</code> is a type that describes the entire universe of possible types; <code>Integer</code> is a subset of <code>Any</code> that includes <code>Int</code>, <code>Int8</code>, and other concrete types.  Internally, Julia also makes heavy use of another type known as <code>Bottom</code>, or equivalently, <code>Union{}</code>.  This corresponds to the empty set.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia&#39;s types support the standard operations of set theory: you can ask whether <code>T1</code> is a &quot;subset&quot; (subtype) of <code>T2</code> with <code>T1 &lt;: T2</code>.  Likewise, you intersect two types using <code>typeintersect</code>, take their union with <code>Union</code>, and compute a type that contains their union with <code>typejoin</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">typeintersect</span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span> </span><span class="kt">Float64</span><span class="p">)</span><span>
</span><span class="go">Union{}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Union</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span> </span><span class="kt">Float64</span><span class="p">}</span><span>
</span><span class="go">Union{Float64,Int64}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">typejoin</span><span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span> </span><span class="kt">Float64</span><span class="p">)</span><span>
</span><span class="go">Real
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">typeintersect</span><span class="p">(</span><span class="n">Signed</span><span class="p">,</span><span> </span><span class="n">Union</span><span class="p">{</span><span class="n">UInt8</span><span class="p">,</span><span> </span><span class="kt">Int8</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">Int8
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Union</span><span class="p">{</span><span class="n">Signed</span><span class="p">,</span><span> </span><span class="n">Union</span><span class="p">{</span><span class="n">UInt8</span><span class="p">,</span><span> </span><span class="kt">Int8</span><span class="p">}</span><span class="p">}</span><span>
</span><span class="go">Union{Signed,UInt8}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">typejoin</span><span class="p">(</span><span class="n">Signed</span><span class="p">,</span><span> </span><span class="n">Union</span><span class="p">{</span><span class="n">UInt8</span><span class="p">,</span><span> </span><span class="kt">Int8</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">Integer
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">typeintersect</span><span class="p">(</span><span class="n">Tuple</span><span class="p">{</span><span class="n">Integer</span><span class="p">,</span><span class="kt">Float64</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="n">Real</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">Tuple{Int64,Float64}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Union</span><span class="p">{</span><span class="n">Tuple</span><span class="p">{</span><span class="n">Integer</span><span class="p">,</span><span class="kt">Float64</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="n">Real</span><span class="p">}</span><span class="p">}</span><span>
</span><span class="go">Union{Tuple{Int64,Real},Tuple{Integer,Float64}}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">typejoin</span><span class="p">(</span><span class="n">Tuple</span><span class="p">{</span><span class="n">Integer</span><span class="p">,</span><span class="kt">Float64</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="n">Real</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">Tuple{Integer,Real}
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>While these operations may seem abstract, they lie at the heart of Julia.  For example, method dispatch is implemented by stepping through the items in a method list until reaching one for which <code>typeintersect(args, sig)</code> is not <code>Union{}</code>.  (Here, <code>args</code> is a tuple-type describing the types of the arguments, and <code>sig</code> is a tuple-type specifying the types in the function&#39;s signature.)  For this algorithm to work, it&#39;s important that methods be sorted by their specificity, and that the search begins with the most specific methods.  Consequently, Julia also implements a partial order on types; this is achieved by functionality that is similar to <code>&lt;:</code>, but with differences that will be discussed below.</p><a id="TypeVars-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>TypeVars</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Many types take parameters; an easy example is <a href="../stdlib/arrays.html#Core.Array"><code>Array</code></a>, which takes two parameters often written as <code>Array{T,N}</code>.  Let&#39;s compare the following methods:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">f1</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="p">:</span><span class="n">Array</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span>
</span><span class="n">f2</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="p">:</span><span class="n">Array</span><span class="p">{</span><span class="kt">Int</span><span class="p">}</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">2</span><span>
</span><span class="n">f3</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="p">:</span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">3</span><span>
</span><span class="n">f4</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="p">:</span><span class="n">Array</span><span class="p">{</span><span class="kt">Any</span><span class="p">}</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">4</span><span>
</span><span class="n">f5</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="kt">Any</span><span class="p">}</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="p">:</span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">5</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>All but <code>f4</code> can be called with <code>a = [1,2]</code>; all but <code>f2</code> can be called with <code>b = Any[1,2]</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Let&#39;s look at these types a little more closely:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Array</span><span>
</span><span class="go">Array{T,N}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">dump</span><span class="p">(</span><span class="n">Array</span><span class="p">)</span><span>
</span><span class="go">Array{T,N} &lt;: DenseArray{T,N}
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This indicates that <a href="../stdlib/arrays.html#Core.Array"><code>Array</code></a> is a shorthand for <code>Array{T,N}</code>.  If you type this at the REPL prompt–on its own, not while defining a function or type–you get an error <code>T not defined</code>. So what, exactly, are <code>T</code> and <code>N</code>? You can learn more by extracting these parameters:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">T</span><span class="p">,</span><span class="n">N</span><span> </span><span class="o">=</span><span> </span><span class="n">Array</span><span class="o">.</span><span class="n">parameters</span><span>
</span><span class="go">svec(T,N)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">dump</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span>
</span><span class="go">TypeVar
</span><span class="go">  name: Symbol T
</span><span class="go">  lb: Union{}
</span><span class="go">  ub: Any
</span><span class="go">  bound: Bool false
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A <code>TypeVar</code> is one of Julia&#39;s built-in types–it&#39;s defined in <code>jltypes.c</code>, although you can find a commented-out version in <code>boot.jl</code>.  The <code>name</code> field is straightforward: it&#39;s what&#39;s printed when showing the object.  <code>lb</code> and <code>ub</code> stand for &quot;lower bound&quot; and &quot;upper bound,&quot; respectively: these are the sets that constrain what types the TypeVar may represent.  In this case, <code>T</code>&#39;s lower bound is <code>Union{}</code> (i.e., <code>Bottom</code> or the empty set); in other words, this <code>TypeVar</code> is not constrained from below.  The upper bound is <code>Any</code>, so neither is it constrained from above.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In a method definition like:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">g</span><span class="p">{</span><span class="n">S</span><span class="o">&lt;:</span><span class="n">Integer</span><span class="p">}</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">S</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">0</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>one can extract the underlying <code>TypeVar</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">g</span><span class="p">{</span><span class="n">S</span><span class="o">&lt;:</span><span class="n">Integer</span><span class="p">}</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">S</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">0</span><span>
</span><span class="n">m</span><span> </span><span class="o">=</span><span> </span><span class="n">first</span><span class="p">(</span><span class="n">methods</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="n">p</span><span> </span><span class="o">=</span><span> </span><span class="n">m</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span>
</span><span class="n">tv</span><span> </span><span class="o">=</span><span> </span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span>
</span><span class="n">dump</span><span class="p">(</span><span class="n">tv</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">TypeVar
  name: Symbol S
  lb: Union{}
  ub: Integer &lt;: Real
  bound: Bool true</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Here <code>ub</code> is <code>Integer</code>, as specified in the function definition.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The last field of a <code>TypeVar</code> is <code>bound</code>.  This boolean value specifies whether the <code>TypeVar</code> is defined as one of the function parameters. For example:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">h1</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="p">:</span><span class="n">Array</span><span class="p">,</span><span> </span><span class="n">b</span><span class="p">:</span><span class="p">:</span><span class="n">Real</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span>
</span><span class="go">h1 (generic function with 1 method)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">h2</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">}</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="p">:</span><span class="n">Array</span><span class="p">,</span><span> </span><span class="n">b</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span>
</span><span class="go">h2 (generic function with 1 method)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">h3</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Real</span><span class="p">}</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="p">:</span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">b</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span>
</span><span class="go">h3 (generic function with 1 method)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">p1</span><span> </span><span class="o">=</span><span> </span><span class="n">first</span><span class="p">(</span><span class="n">methods</span><span class="p">(</span><span class="n">h1</span><span class="p">)</span><span class="p">)</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span>
</span><span class="go">svec(#h1,Array{T,N},Real)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">p2</span><span> </span><span class="o">=</span><span> </span><span class="n">first</span><span class="p">(</span><span class="n">methods</span><span class="p">(</span><span class="n">h2</span><span class="p">)</span><span class="p">)</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span>
</span><span class="go">svec(#h2,Array{T,N},T&lt;:Real)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">p3</span><span> </span><span class="o">=</span><span> </span><span class="n">first</span><span class="p">(</span><span class="n">methods</span><span class="p">(</span><span class="n">h3</span><span class="p">)</span><span class="p">)</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span>
</span><span class="go">svec(#h3,Array{T&lt;:Real,N},T&lt;:Real)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">dump</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="p">)</span><span>
</span><span class="go">TypeVar
</span><span class="go">  name: Symbol T
</span><span class="go">  lb: Union{}
</span><span class="go">  ub: Any
</span><span class="go">  bound: Bool false
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">dump</span><span class="p">(</span><span class="n">p3</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="p">)</span><span>
</span><span class="go">TypeVar
</span><span class="go">  name: Symbol T
</span><span class="go">  lb: Union{}
</span><span class="go">  ub: Real &lt;: Number
</span><span class="go">  bound: Bool true
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Note that <code>p2</code> shows two objects called <code>T</code>, but only one of them has the upper bound <code>Real</code>; in contrast, <code>p3</code> shows both of them bounded.  This is because in <code>h3</code>, the same type <code>T</code> is used in both places, whereas for <code>h2</code> the <code>T</code> inside the array is simply the default symbol used for the first parameter of <a href="../stdlib/arrays.html#Core.Array"><code>Array</code></a>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>One can construct <code>TypeVar</code>s manually:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">TypeVar</span><span class="p">(</span><span class="p">:</span><span class="n">V</span><span class="p">,</span><span> </span><span class="n">Signed</span><span class="p">,</span><span> </span><span class="n">Real</span><span class="p">,</span><span> </span><span class="n">false</span><span class="p">)</span><span>
</span><span class="go">Signed&lt;:V&lt;:Real
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>There are convenience versions that allow you to omit any of these arguments except the <code>name</code> symbol.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Armed with this information, we can do some sneaky things that reveal a lot about how Julia does dispatch:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">TV</span><span> </span><span class="o">=</span><span> </span><span class="n">TypeVar</span><span class="p">(</span><span class="p">:</span><span class="n">T</span><span class="p">,</span><span> </span><span class="n">false</span><span class="p">)</span><span>   </span><span class="c"># bound = false</span><span>
</span><span class="go">T
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">candid</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="p">:</span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">0</span><span>
</span><span class="go">candid (generic function with 1 method)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="p">@</span><span class="n">eval</span><span> </span><span class="n">sneaky</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="p">:</span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="o">$</span><span class="n">TV</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span>
</span><span class="go">sneaky (generic function with 1 method)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">methods</span><span class="p">(</span><span class="n">candid</span><span class="p">)</span><span>
</span><span class="go"># 1 method for generic function &quot;candid&quot;:
</span><span class="go">candid{T}(A::Array{T,N&lt;:Any}, x::T) at none:1
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">methods</span><span class="p">(</span><span class="n">sneaky</span><span class="p">)</span><span>
</span><span class="go"># 1 method for generic function &quot;sneaky&quot;:
</span><span class="go">sneaky{T}(A::Array{T,N&lt;:Any}, x::T&lt;:Any) at none:1
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>These therefore print identically, but they have very different behavior:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">candid</span><span class="p">(</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="p">,</span><span class="mf">3.2</span><span class="p">)</span><span>
</span><span class="go">ERROR: MethodError: no method matching candid(::Array{Int64,1}, ::Float64)
</span><span class="go">Closest candidates are:
</span><span class="go">  candid{T}(::Array{T,N}, !Matched::T)
</span><span class="go"> ...
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">sneaky</span><span class="p">(</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="p">,</span><span class="mf">3.2</span><span class="p">)</span><span>
</span><span class="go">1
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>To see what&#39;s happening, it&#39;s helpful to use Julia&#39;s internal <code>jl_()</code> function (defined in <code>builtins.c</code>) for display, because it prints bound <code>TypeVar</code> objects with a hash (<code>#T</code> instead of <code>T</code>):</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">jl_</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="k">ccall</span><span class="p">(</span><span class="p">:</span><span class="n">jl_</span><span class="p">,</span><span> </span><span class="n">Void</span><span class="p">,</span><span> </span><span class="p">(</span><span class="kt">Any</span><span class="p">,</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">x</span><span class="p">)</span><span>
</span><span class="go">jl_ (generic function with 1 method)
</span></code></pre><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">jl_</span><span class="p">(</span><span class="n">first</span><span class="p">(</span><span class="n">methods</span><span class="p">(</span><span class="n">candid</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">Method(sig=Tuple{Main.#candid, Array{#T&lt;:Any, N&lt;:Any}, #T&lt;:Any}, va=false, isstaged=false, tvars=#T&lt;:Any, func=Main.candid(?), invokes=nothing, next=nothing)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">jl_</span><span class="p">(</span><span class="n">first</span><span class="p">(</span><span class="n">methods</span><span class="p">(</span><span class="n">sneaky</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">Method(sig=Tuple{Main.#sneaky, Array{#T&lt;:Any, N&lt;:Any}, T&lt;:Any}, va=false, isstaged=false, tvars=#T&lt;:Any, func=Main.sneaky(?), invokes=nothing, next=nothing)
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Even though both print as <code>T</code>, in <code>sneaky</code> the second <code>T</code> is not bound, and hence it isn&#39;t constrained to be the same type as the element type of the <a href="../stdlib/arrays.html#Core.Array"><code>Array</code></a>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Some <code>TypeVar</code> interactions depend on the <code>bound</code> state, even when there are not two or more uses of the same <code>TypeVar</code>. For example:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">S</span><span> </span><span class="o">=</span><span> </span><span class="n">TypeVar</span><span class="p">(</span><span class="p">:</span><span class="n">S</span><span class="p">,</span><span> </span><span class="n">false</span><span class="p">)</span><span class="p">;</span><span> </span><span class="n">T</span><span> </span><span class="o">=</span><span> </span><span class="n">TypeVar</span><span class="p">(</span><span class="p">:</span><span class="n">T</span><span class="p">,</span><span> </span><span class="n">true</span><span class="p">)</span><span>
</span><span class="go">T
</span><span class="go">
</span><span class="go"># These would be the same no matter whether we used S or T
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="n">S</span><span class="p">}</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">Array</span><span class="p">}</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="n">S</span><span class="p">}</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="n">S</span><span class="p">}</span><span class="p">}</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">Array</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="n">S</span><span class="p">}</span><span class="p">}</span><span>
</span><span class="go">true
</span><span class="go">
</span><span class="go"># For these cases, it matters
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="kt">Int</span><span class="p">}</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">Array</span><span class="p">}</span><span>
</span><span class="go">false
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="kt">Int</span><span class="p">}</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="n">S</span><span class="p">}</span><span class="p">}</span><span>
</span><span class="go">false
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="kt">Int</span><span class="p">}</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">}</span><span>
</span><span class="go">true
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>It&#39;s this latter construction that allows function declarations like</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">foo</span><span class="p">{</span><span class="n">T</span><span class="p">,</span><span class="n">N</span><span class="p">}</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="p">:</span><span class="n">Array</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">,</span><span class="n">N</span><span class="p">}</span><span class="p">}</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">T</span><span class="p">,</span><span class="n">N</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>to match despite the invariance of Julia&#39;s type parameters.</p><a id="TypeNames-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>TypeNames</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The following two <a href="../stdlib/arrays.html#Core.Array"><code>Array</code></a> types are functionally equivalent, yet print differently via <code>jl_()</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">TV</span><span class="p">,</span><span> </span><span class="n">NV</span><span> </span><span class="o">=</span><span> </span><span class="n">TypeVar</span><span class="p">(</span><span class="p">:</span><span class="n">T</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">TypeVar</span><span class="p">(</span><span class="p">:</span><span class="n">N</span><span class="p">)</span><span>
</span><span class="go">(T,N)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">jl_</span><span class="p">(</span><span class="n">Array</span><span class="p">)</span><span>
</span><span class="go">Array
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">jl_</span><span class="p">(</span><span class="n">Array</span><span class="p">{</span><span class="n">TV</span><span class="p">,</span><span class="n">NV</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">Array{T&lt;:Any, N&lt;:Any}
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>These can be distinguished by examining the <code>name</code> field of the type, which is an object of type <code>TypeName</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">dump</span><span class="p">(</span><span class="n">Array</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span>
</span><span class="go">TypeName
</span><span class="go">  name: Symbol Array
</span><span class="go">  module: Module Core
</span><span class="go">  names: empty SimpleVector
</span><span class="go">  primary: Array{T,N} &lt;: DenseArray{T,N}
</span><span class="go">  cache: SimpleVector
</span><span class="go">    ...
</span><span class="go">  linearcache: SimpleVector
</span><span class="go">    ...
</span><span class="go">  uid: Int64 47
</span><span class="go">  mt: MethodTable
</span><span class="go">    name: Symbol Array
</span><span class="go">    defs: Void nothing
</span><span class="go">    cache: Void nothing
</span><span class="go">    max_args: Int64 0
</span><span class="go">    kwsorter: #undef
</span><span class="go">    module: Module Core
</span><span class="go">    : Int64 0
</span><span class="go">    : Int64 0
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In this case, the relevant field is <code>primary</code>, which holds a reference to the &quot;primary&quot; instance of the type:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">pointer_from_objref</span><span class="p">(</span><span class="n">Array</span><span class="p">)</span><span>
</span><span class="go">Ptr{Void} @0x00007fcc7de64850
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">pointer_from_objref</span><span class="p">(</span><span class="n">Array</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">primary</span><span class="p">)</span><span>
</span><span class="go">Ptr{Void} @0x00007fcc7de64850
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">pointer_from_objref</span><span class="p">(</span><span class="n">Array</span><span class="p">{</span><span class="n">TV</span><span class="p">,</span><span class="n">NV</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">Ptr{Void} @0x00007fcc80c4d930
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">pointer_from_objref</span><span class="p">(</span><span class="n">Array</span><span class="p">{</span><span class="n">TV</span><span class="p">,</span><span class="n">NV</span><span class="p">}</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">primary</span><span class="p">)</span><span>
</span><span class="go">Ptr{Void} @0x00007fcc7de64850
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The <code>primary</code> field of <a href="../stdlib/arrays.html#Core.Array"><code>Array</code></a> points to itself, but for <code>Array{TV,NV}</code> it points back to the default definition of the type.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>What about the other fields? <code>uid</code> assigns a unique integer to each type.  To examine the <code>cache</code> field, it&#39;s helpful to pick a type that is less heavily used than Array. Let&#39;s first create our own type:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="k">type</span><span class="nc"> </span><span class="nc">MyType</span><span class="p">{</span><span class="n">T</span><span class="p">,</span><span class="n">N</span><span class="p">}</span><span> </span><span class="k">end</span><span>
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">MyType</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span>
</span><span class="go">MyType{Int64,2}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">MyType</span><span class="p">{</span><span class="kt">Float32</span><span class="p">,</span><span> </span><span class="mi">5</span><span class="p">}</span><span>
</span><span class="go">MyType{Float32,5}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">MyType</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">cache</span><span>
</span><span class="go">svec(MyType{Float32,5},MyType{Int64,2},#undef,#undef,#undef,#undef,#undef,#undef)
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>(The cache is pre-allocated to have length 8, but only the first two entries are populated.) Consequently, when you instantiate a parametric type, each concrete type gets saved in a type-cache.  However, instances with <code>TypeVar</code> parameters are not cached.</p><a id="Tuple-types-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Tuple-types</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Tuple-types constitute an interesting special case.  For dispatch to work on declarations like <code>x::Tuple</code>, the type has to be able to be able to accommodate any tuple.  Let&#39;s check the parameters:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Tuple</span><span>
</span><span class="go">Tuple
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Tuple</span><span class="o">.</span><span class="n">parameters</span><span>
</span><span class="go">svec(Vararg{Any,N})
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>It&#39;s worth noting that the parameter is a type, <code>Any</code>, rather than a <code>TypeVar T&lt;:Any</code>: compare</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">jl_</span><span class="p">(</span><span class="n">Tuple</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span><span>
</span><span class="go">svec(Vararg{Any, N&lt;:Any})
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">jl_</span><span class="p">(</span><span class="n">Array</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span><span>
</span><span class="go">svec(T&lt;:Any, N&lt;:Any)
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Unlike other types, tuple-types are covariant in their parameters, so this definition permits <code>Tuple</code> to match any type of tuple.  This is therefore equivalent to having an unbound <code>TypeVar</code> but distinct from a bound <code>TypeVar</code></p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">typeintersect</span><span class="p">(</span><span class="n">Tuple</span><span class="p">,</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="kt">Float64</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">Tuple{Int64,Float64}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">typeintersect</span><span class="p">(</span><span class="n">Tuple</span><span class="p">{</span><span class="n">Vararg</span><span class="p">{</span><span class="kt">Any</span><span class="p">}</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="kt">Float64</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">Tuple{Int64,Float64}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">T</span><span> </span><span class="o">=</span><span> </span><span class="n">TypeVar</span><span class="p">(</span><span class="p">:</span><span class="n">T</span><span class="p">,</span><span class="n">false</span><span class="p">)</span><span>
</span><span class="go">T
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">typeintersect</span><span class="p">(</span><span class="n">Tuple</span><span class="p">{</span><span class="n">Vararg</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="kt">Float64</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">Tuple{Int64,Float64}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">T</span><span> </span><span class="o">=</span><span> </span><span class="n">TypeVar</span><span class="p">(</span><span class="p">:</span><span class="n">T</span><span class="p">,</span><span class="n">true</span><span class="p">)</span><span>
</span><span class="go">T
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">typeintersect</span><span class="p">(</span><span class="n">Tuple</span><span class="p">{</span><span class="n">Vararg</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="kt">Float64</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">Union{}
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Finally, it&#39;s worth noting that <code>Tuple{}</code> is distinct</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="p">}</span><span>
</span><span class="go">Tuple{}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="p">}</span><span class="o">.</span><span class="n">parameters</span><span>
</span><span class="go">svec()
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">typeintersect</span><span class="p">(</span><span class="n">Tuple</span><span class="p">{</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">Union{}
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>What is the &quot;primary&quot; tuple-type?</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">pointer_from_objref</span><span class="p">(</span><span class="n">Tuple</span><span class="p">)</span><span>
</span><span class="go">Ptr{Void} @0x00007f5998a04370
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">pointer_from_objref</span><span class="p">(</span><span class="n">Tuple</span><span class="p">{</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">Ptr{Void} @0x00007f5998a570d0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">pointer_from_objref</span><span class="p">(</span><span class="n">Tuple</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">primary</span><span class="p">)</span><span>
</span><span class="go">Ptr{Void} @0x00007f5998a04370
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">pointer_from_objref</span><span class="p">(</span><span class="n">Tuple</span><span class="p">{</span><span class="p">}</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">primary</span><span class="p">)</span><span>
</span><span class="go">Ptr{Void} @0x00007f5998a04370
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>so <code>Tuple == Tuple{Vararg{Any}}</code> is indeed the primary type.</p><a id="Introduction-to-the-internal-machinery:-jltypes.c-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Introduction to the internal machinery: <code>jltypes.c</code></h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Many operations for dealing with types are found in the file <code>jltypes.c</code>. A good way to start is to watch type intersection in action.  Build Julia with <code>make debug</code> and fire up Julia within a debugger. <a href="debuggingtips.html#gdb-debugging-tips-1">gdb debugging tips</a> has some tips which may be useful.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Because the type intersection and matching code is used heavily in the REPL itself–and hence breakpoints in this code get triggered often–it will be easiest if you make the following definition:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="k">function</span><span class="nf"> </span><span class="nf">myintersect</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span>
</span><span class="gt">
           ccall(:jl_breakpoint, Void, (Any,), nothing)
</span><span></span><span class="gt">
           typeintersect(a, b)
</span><span></span><span class="gt">
       end
</span><span></span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>and then set a breakpoint in <code>jl_breakpoint</code>.  Once this breakpoint gets triggered, you can set breakpoints in other functions.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>As a warm-up, try the following:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">myintersect</span><span class="p">(</span><span class="n">Tuple</span><span class="p">{</span><span class="n">Integer</span><span class="p">,</span><span class="kt">Float64</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="n">Real</span><span class="p">}</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Set a breakpoint in <code>intersect_tuple</code> and continue until it enters this function.  You should be able to see something like this:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">Breakpoint 2, intersect_tuple (a=0x7ffdf7409150, b=0x7ffdf74091b0, penv=0x7fffffffcc90, eqc=0x7fffffffcc70, var=covariant) at jltypes.c:405
405     {
(gdb) call jl_(a)
Tuple{Integer, Float64}
(gdb) call jl_(b)
Tuple{Int64, Real}</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The <code>var</code> argument is either <code>covariant</code> or <code>invariant</code>, the latter being used if you&#39;re matching the type parameters of <code>Array{T1}</code> against <code>Array{T2}</code>.  The other two inputs to this function (<code>penv</code> and <code>eqc</code>) may be currently mysterious, but we&#39;ll discuss them in a moment.  For now, step through the code until you get into the loop over the different entries in the tuple types <code>a</code> and <code>b</code>.  The key call is:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">ce</span><span> </span><span class="o">=</span><span> </span><span class="n">jl_type_intersect</span><span class="p">(</span><span class="n">ae</span><span class="p">,</span><span class="n">be</span><span class="p">,</span><span class="n">penv</span><span class="p">,</span><span class="n">eqc</span><span class="p">,</span><span class="n">var</span><span class="p">)</span><span class="p">;</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>which, if you examine <code>ae</code>, <code>be</code>, and <code>ce</code>, you&#39;ll see is just type intersection performed on these entries.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>We can make it more interesting by trying a more complex case:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">T</span><span> </span><span class="o">=</span><span> </span><span class="n">TypeVar</span><span class="p">(</span><span class="p">:</span><span class="n">T</span><span class="p">,</span><span> </span><span class="n">true</span><span class="p">)</span><span>
</span><span class="go">T
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">myintersect</span><span class="p">(</span><span class="n">Tuple</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">T</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="p">,</span><span> </span><span class="kt">Int8</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">
</span><span class="go">Breakpoint 1, jl_breakpoint (v=0x7ffdf35e8010) at builtins.c:1559
</span><span class="go">1559    {
</span><span class="go">(gdb) b intersect_tuple
</span><span class="go">Breakpoint 3 at 0x7ffff6dcb07d: file jltypes.c, line 405.
</span><span class="go">(gdb) c
</span><span class="go">Continuing.
</span><span class="go">
</span><span class="go">Breakpoint 3, intersect_tuple (a=0x7ffdf74d7a90, b=0x7ffdf74d7af0, penv=0x7fffffffcc90, eqc=0x7fffffffcc70, var=covariant) at jltypes.c:405
</span><span class="go">405     {
</span><span class="go">(gdb) call jl_(a)
</span><span class="go">Tuple{Array{＃T&lt;:Any, N&lt;:Any}, ＃T&lt;:Any}
</span><span class="go">(gdb) call jl_(b)
</span><span class="go">Tuple{Array{Int64, 2}, Int8}
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Let&#39;s watch how this bound <code>TypeVar</code> gets handled.  To follow this, you&#39;ll need to examine the variables <code>penv</code> and <code>eqc</code>, which are defined as:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">typedef struct {
    jl_value_t **data;
    size_t n;
    jl_svec_t *tvars;
} cenv_t;</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>These start out empty (with <code>penv-&gt;n == eqc-&gt;n == 0</code>).  Once we get into the loop and make the first call to <code>jl_type_intersect</code>, <code>eqc</code> (which stands for &quot;equality constraints&quot;) has the following value:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">(gdb) p eqc-&gt;n
$4 = 2
(gdb) call jl_(eqc-&gt;data[0])
＃T&lt;:Any
(gdb) call jl_(eqc-&gt;data[1])
Int64</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This is just a <code>var</code>, <code>value</code> list of pairs, indicating that <code>T</code> now has the value <code>Int64</code>.  If you now allow <code>intersect_tuple</code> to finish and keep progressing, you&#39;ll eventually get to <code>type_intersection_matching</code>.  This function contains a call to <code>solve_tvar_constraints</code>.  Roughly speaking, <code>eqc</code> defines <code>T = Int64</code>, but <code>env</code> defines it as <code>Int8</code>; this conflict is detected in <code>solve_tvar_constraints</code> and the resulting return is <code>jl_bottom_type</code>, aka <code>Union{}</code>.</p><a id="Subtyping-and-method-sorting-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Subtyping and method sorting</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Armed with this knowledge, you may find yourself surprised by the following:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">typeintersect</span><span class="p">(</span><span class="n">Tuple</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="kt">Int</span><span class="p">}</span><span class="p">,</span><span class="kt">Float64</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">,</span><span class="n">T</span><span class="p">}</span><span class="p">)</span><span>
</span><span class="go">Union{}
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="kt">Int</span><span class="p">}</span><span class="p">,</span><span class="kt">Float64</span><span class="p">}</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Tuple</span><span class="p">{</span><span class="n">Array</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">,</span><span class="n">T</span><span class="p">}</span><span>
</span><span class="go">true
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>where <code>T</code> is a bound <code>TypeVar</code>.  In other words, <code>A &lt;: B</code> does not imply that <code>typeintersect(A, B) == A</code>.  A little bit of digging reveals the reason why: <code>jl_subtype_le</code> does not use the <code>cenv_t</code> constraints that we just saw in <code>typeintersect</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p><code>jltypes.c</code> contains three closely related collections of functions for testing how types <code>a</code> and <code>b</code> are ordered:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>The <code>subtype</code> functions implement <code>a &lt;: b</code>. Among other uses, they serve in matching function arguments against method signatures in the function cache.</p></li><li><p>The <code>type_morespecific</code> functions are used for imposing a partial order on functions in method tables (from most-to-least specific). Note that <code>jl_type_morespecific(a,b,0)</code> really means &quot;is <code>a</code> at least as specific as <code>b</code>?&quot; and not &quot;is <code>a</code> strictly more specific than <code>b</code>?&quot;</p></li><li><p>The <code>type_match</code> functions are similar to <code>type_morespecific</code>, but additionally accept (and employ) an environment to constrain typevars. The related <code>type_match_morespecific</code> functions call <code>type_match</code> with an argument <code>morespecific=1</code></p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>All three of these take an argument, <code>invariant</code>, which is set to 1 when comparing type parameters and otherwise is 0.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The rules for these are somewhat different. <code>subtype</code> is sensitive to the number arguments, but <code>type_morespecific</code> may not be. In particular, <code>Tuple{Int,AbstractFloat}</code> is more specific than <code>Tuple{Integer}</code>, even though it is not a subtype.  (Of <code>Tuple{Int,AbstractFloat}</code> and <code>Tuple{Integer,Float64}</code>, neither is more specific than the other.)  Likewise, <code>Tuple{Int,Vararg{Int}}</code> is not a subtype of <code>Tuple{Integer}</code>, but it is considered more specific. However, <code>morespecific</code> does get a bonus for length: in particular, <code>Tuple{Int,Int}</code> is more specific than <code>Tuple{Int,Vararg{Int}}</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If you&#39;re debugging how methods get sorted, it can be convenient to define the function:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">args_morespecific</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span> </span><span class="n">b</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="k">ccall</span><span class="p">(</span><span class="p">:</span><span class="n">jl_args_morespecific</span><span class="p">,</span><span> </span><span class="n">Cint</span><span class="p">,</span><span> </span><span class="p">(</span><span class="kt">Any</span><span class="p">,</span><span class="kt">Any</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">a</span><span class="p">,</span><span> </span><span class="n">b</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>which allows you to test whether arg-tuple <code>a</code> is more specific than arg-tuple <code>b</code>.</p><footer><hr/><a class="previous" href="sysimg.html"><span class="direction">Previous</span><span class="title">System Image Building</span></a><a class="next" href="valgrind.html"><span class="direction">Next</span><span class="title">Using Valgrind with Julia</span></a></footer></article></body></html>
