<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documenter.jl</title><link href="../normalize.css" rel="stylesheet" type="text/css"/><link href="../style.css" rel="stylesheet" type="text/css"/><link href="../highlight.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="../require.js" data-main="../documenter.js"></script><script src="../search-index.js"></script></head><body><nav class="toc"><a href="http://julialang.org/"><img class="logo" src="http://docs.julialang.org/en/release-0.4/_static/julia-logo.svg" alt="\$pkgname.jl logo"/></a><h1>$pkgname.jl</h1><input type="text" placeholder="Search docs"/><ul><li><a class="toctext" href="../index.html">Overview</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/guide.html">Guide</a></li><li><a class="toctext" href="../man/examples.html">Examples</a></li><li><a class="toctext" href="../man/syntax.html">Syntax</a></li><li><a class="toctext" href="../man/doctests.html">Doctests</a></li><li><a class="toctext" href="../man/hosting.html">Hosting Documentation</a></li><li><a class="toctext" href="../man/latex.html"><span>$\LaTeX$</span> syntax</a></li><li><a class="toctext" href="../man/internals.html">Package Internals</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../lib/public.html">Public Documentation</a></li><li><a class="toctext" href="../lib/internals.html">Internal Documentation</a></li></ul></li><li><span class="toctext">Dynamic pages</span><ul><li><a class="toctext" href="../dynamic/code.html">Code examples</a></li><li><a class="toctext" href="../dynamic/admonitions.html">Admonitions &amp; Co</a></li><li><a class="toctext" href="../dynamic/styles.html">Demonstrating <em>styles</em> of MD elements</a></li><li><a class="toctext" href="../dynamic/bugs.html">Some existing bugs</a></li></ul></li><li><span class="toctext">JuliaDocs - Manual</span><ul><li><a class="toctext" href="../manual/arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../manual/calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="../manual/complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="../manual/constructors.html">Constructors</a></li><li><a class="toctext" href="../manual/control-flow.html">Control Flow</a></li><li><a class="toctext" href="../manual/conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="../manual/dates.html">Date and DateTime</a></li><li><a class="toctext" href="../manual/documentation.html">Documentation</a></li><li><a class="toctext" href="../manual/embedding.html">Embedding Julia</a></li><li><a class="toctext" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="../manual/functions.html">Functions</a></li><li><a class="toctext" href="../manual/getting-started.html">Getting Started</a></li><li><a class="toctext" href="../manual/handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="../manual/index.html">The Julia Manual</a></li><li><a class="toctext" href="../manual/integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../manual/interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="../manual/interfaces.html">Interfaces</a></li><li><a class="toctext" href="../manual/introduction.html">Introduction</a></li><li><a class="toctext" href="../manual/linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="../manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../manual/metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="../manual/methods.html">Methods</a></li><li><a class="toctext" href="../manual/modules.html">Modules</a></li><li><a class="toctext" href="../manual/networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="../manual/noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../manual/packages.html">Packages</a></li><li><a class="toctext" href="../manual/parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="../manual/performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="../manual/profile.html">Profiling</a></li><li><a class="toctext" href="../manual/running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="../manual/stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="../manual/strings.html">Strings</a></li><li><a class="toctext" href="../manual/style-guide.html">Style Guide</a></li><li><a class="toctext" href="../manual/types.html">Types</a></li><li><a class="toctext" href="../manual/unicode-input.html">Unicode Input</a></li><li><a class="toctext" href="../manual/variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="../manual/variables.html">Variables</a></li><li><a class="toctext" href="../manual/workflow-tips.html">Workflow Tips</a></li></ul></li><li><span class="toctext">JuliaDocs - Standard Libary</span><ul><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/c.html">C Interface</a></li><li><a class="toctext" href="../stdlib/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../stdlib/constants.html">Constants</a></li><li><a class="toctext" href="../stdlib/dates.html">Dates and Time</a></li><li><a class="toctext" href="../stdlib/file.html">Filesystem</a></li><li><a class="toctext" href="../stdlib/index.html">The Julia Standard Library</a></li><li><a class="toctext" href="../stdlib/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../stdlib/libc.html">C Standard Library</a></li><li><a class="toctext" href="../stdlib/libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/linalg.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/math.html">Mathematics</a></li><li><a class="toctext" href="../stdlib/numbers.html">Numbers</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="../stdlib/pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../stdlib/simd-types.html">SIMD Support</a></li><li><a class="toctext" href="../stdlib/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../stdlib/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../stdlib/strings.html">Strings</a></li><li><a class="toctext" href="../stdlib/test.html">Unit Testing</a></li></ul></li><li><span class="toctext">JuliaDocs - DevDocs</span><ul><li><a class="toctext" href="ast.html">Julia ASTs</a></li><li><a class="toctext" href="backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="callconv.html">Calling Conventions</a></li><li><a class="toctext" href="cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="C.html">Developing/debugging Julia&#39;s C code</a></li><li><a class="toctext" href="debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="eval.html">Eval of Julia code</a></li><li class="current"><a class="toctext" href="functions.html">Julia Functions</a><ul class="internal"><li><a class="toctext" href="#Method-Tables-1">Method Tables</a></li><li><a class="toctext" href="#Function-calls-1">Function calls</a></li><li><a class="toctext" href="#Adding-methods-1">Adding methods</a></li><li><a class="toctext" href="#Creating-generic-functions-1">Creating generic functions</a></li><li><a class="toctext" href="#Closures-1">Closures</a></li><li><a class="toctext" href="#Constructors-1">Constructors</a></li><li><a class="toctext" href="#Builtins-1">Builtins</a></li><li><a class="toctext" href="#Keyword-arguments-1">Keyword arguments</a></li><li><a class="toctext" href="#Compiler-efficiency-issues-1">Compiler efficiency issues</a></li></ul></li><li><a class="toctext" href="init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="julia.html">Documentation of Julia&#39;s Internals</a></li><li><a class="toctext" href="llvm.html">Working with LLVM</a></li><li><a class="toctext" href="locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="promote-op.html">Operator-sensitive promotion</a></li><li><a class="toctext" href="reflection.html">Reflection and introspection</a></li><li><a class="toctext" href="stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="subarrays.html">SubArrays</a></li><li><a class="toctext" href="sysimg.html">System Image Building</a></li><li><a class="toctext" href="types.html">More about types</a></li><li><a class="toctext" href="valgrind.html">Using Valgrind with Julia</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>JuliaDocs - DevDocs</li><li><a href="functions.html">Julia Functions</a></li></ul><a class="edit-page" href="https://github.com/"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><a id="Julia-Functions-1"></a><div class="mdnote debug">Base.Markdown.Header{1}</div><h1>Julia Functions</h1><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This document will explain how functions, method definitions, and method tables work.</p><a id="Method-Tables-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Method Tables</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Every function in Julia is a generic function. A generic function is conceptually a single function, but consists of many definitions, or methods. The methods of a generic function are stored in a method table. Method tables (type <code>MethodTable</code>) are associated with <code>TypeName</code>s. A <code>TypeName</code> describes a family of parameterized types. For example <code>Complex{Float32}</code> and <code>Complex{Float64}</code> share the same <code>Complex</code> type name object.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>All objects in Julia are potentially callable, because every object has a type, which in turn has a <code>TypeName</code>.</p><a id="Function-calls-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Function calls</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Given the call <code>f(x,y)</code>, the following steps are performed: first, the method table to use is accessed as <code>typeof(f).name.mt</code>. Second, an argument tuple type is formed, <code>Tuple{typeof(f), typeof(x), typeof(y)}</code>. Note that the type of the function itself is the first element. This is because the type might have parameters, and so needs to take part in dispatch. This tuple type is looked up in the method table.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This dispatch process is performed by <code>jl_apply_generic</code>, which takes two arguments: a pointer to an array of the values f, x, and y, and the number of values (in this case 3).</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Throughout the system, there are two kinds of APIs that handle functions and argument lists: those that accept the function and arguments separately, and those that accept a single argument structure. In the first kind of API, the &quot;arguments&quot; part does <em>not</em> contain information about the function, since that is passed separately. In the second kind of API, the function is the first element of the argument structure.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For example, the following function for performing a call accepts just an <code>args</code> pointer, so the first element of the args array will be the function to call:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">jl_value_t *jl_apply(jl_value_t **args, uint32_t nargs)</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This entry point for the same functionality accepts the function separately, so the <code>args</code> array does not contain the function:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs);</code></pre><a id="Adding-methods-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Adding methods</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Given the above dispatch process, conceptually all that is needed to add a new method is (1) a tuple type, and (2) code for the body of the method. <code>jl_method_def</code> implements this operation. <code>jl_first_argument_datatype</code> is called to extract the relevant method table from what would be the type of the first argument. This is much more complicated than the corresponding procedure during dispatch, since the argument tuple type might be abstract. For example, we can define:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="p">(</span><span class="p">:</span><span class="p">:</span><span class="n">Union</span><span class="p">{</span><span class="n">Foo</span><span class="p">{</span><span class="kt">Int</span><span class="p">}</span><span class="p">,</span><span class="n">Foo</span><span class="p">{</span><span class="kt">Int8</span><span class="p">}</span><span class="p">}</span><span class="p">)</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">0</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>which works since all possible matching methods would belong to the same method table.</p><a id="Creating-generic-functions-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Creating generic functions</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Since every object is callable, nothing special is needed to create a generic function. Therefore <code>jl_new_generic_function</code> simply creates a new singleton (0 size) subtype of <code>Function</code> and returns its instance. A function can have a mnemonic &quot;display name&quot; which is used in debug info and when printing objects. For example the name of <code>Base.sin</code> is <code>sin</code>. By convention, the name of the created <em>type</em> is the same as the function name, with a <code>#</code> prepended. So <code>typeof(sin)</code> is <code>Base.#sin</code>.</p><a id="Closures-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Closures</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A closure is simply a callable object with field names corresponding to captured variables. For example, the following code:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">adder</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span>
</span><span>    </span><span class="k">return</span><span> </span><span class="n">y</span><span class="o">-&gt;</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>is lowered to (roughly):</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">immutable</span><span> </span><span class="c">##1{T}</span><span>
</span><span>    </span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span>
</span><span class="k">end</span><span>
</span><span>
</span><span class="p">(</span><span class="n">_</span><span class="p">:</span><span class="p">:</span><span class="c">##1)(y) = _.x + y</span><span>
</span><span>
</span><span class="k">function</span><span class="nf"> </span><span class="nf">adder</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span>
</span><span>    </span><span class="k">return</span><span> </span><span class="c">##1(x)</span><span>
</span><span class="k">end</span><span>
</span></code></pre><a id="Constructors-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Constructors</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A constructor call is just a call to a type. The type of most types is <code>DataType</code>, so the method table for <code>DataType</code> contains most constructor definitions. One wrinkle is the fallback definition that makes all types callable via <code>convert</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="p">(</span><span class="p">:</span><span class="p">:</span><span class="n">Type</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">)</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="nb">convert</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span> </span><span class="n">args</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="p">)</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In this definition the function type is abstract, which is not normally supported. To make this work, all subtypes of <code>Type</code> (<code>Type</code>, <code>TypeConstructor</code>, <code>Union</code>, and <code>DataType</code>) currently share a method table via special arrangement.</p><a id="Builtins-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Builtins</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The &quot;builtin&quot; functions, defined in the <code>Core</code> module, are:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">is typeof sizeof issubtype isa typeassert throw tuple getfield setfield! fieldtype
nfields isdefined arrayref arrayset arraysize applicable invoke apply_type _apply
_expr svec</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>These are all singleton objects whose types are subtypes of <code>Builtin</code>, which is a subtype of <code>Function</code>. Their purpose is to expose entry points in the run time that use the &quot;jlcall&quot; calling convention:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">jl_value_t *(jl_value_t*, jl_value_t**, uint32_t)</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The method tables of builtins are empty. Instead, they have a single catch-all method cache entry (<code>Tuple{Vararg{Any}}</code>) whose jlcall fptr points to the correct function. This is kind of a hack but works reasonably well.</p><a id="Keyword-arguments-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Keyword arguments</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Keyword arguments work by associating a special, hidden function object with each method table that has definitions with keyword arguments. This function is called the &quot;keyword argument sorter&quot; or &quot;keyword sorter&quot;, or &quot;kwsorter&quot;, and is stored in the <code>kwsorter</code> field of <code>MethodTable</code> objects. Every definition in the kwsorter function has the same arguments as some definition in the normal method table, except with a single <code>Array</code> argument prepended. This array contains alternating symbols and values that represent the passed keyword arguments. The kwsorter&#39;s job is to move keyword arguments into their canonical positions based on name, plus evaluate and substite any needed default value expressions. The result is a normal positional argument list, which is then passed to yet another function.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The easiest way to understand the process is to look at how a keyword argument method definition is lowered. The code:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">circle</span><span class="p">(</span><span class="n">center</span><span class="p">,</span><span> </span><span class="n">radius</span><span class="p">;</span><span> </span><span class="n">color</span><span> </span><span class="o">=</span><span> </span><span class="n">black</span><span class="p">,</span><span> </span><span class="n">fill</span><span class="p">:</span><span class="p">:</span><span class="kt">Bool</span><span> </span><span class="o">=</span><span> </span><span class="n">true</span><span class="p">,</span><span> </span><span class="n">options</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="p">)</span><span>
</span><span>    </span><span class="c"># draw</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>actually produces <em>three</em> method definitions. The first is a function that accepts all arguments (including keywords) as positional arguments, and includes the code for the method body. It has an auto-generated name:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">function #circle#1(color, fill::Bool, options, circle, center, radius)
    # draw
end</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The second method is an ordinary definition for the original <code>circle</code> function, which handles the case where no keyword arguments are passed:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">circle</span><span class="p">(</span><span class="n">center</span><span class="p">,</span><span> </span><span class="n">radius</span><span class="p">)</span><span>
</span><span>    </span><span class="c">#circle#1(black, true, Any[], circle, center, radius)</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This simply dispatches to the first method, passing along default values. Finally there is the kwsorter definition:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">function (::Core.kwftype(typeof(circle)))(kw::Array, circle, center, radius)
    options = Any[]
    color = arg associated with :color, or black if not found
    fill = arg associated with :fill, or true if not found
    # push remaining elements of kw into options array
    #circle#1(color, fill, options, circle, center, radius)
end</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The front end generates code to loop over the <code>kw</code> array and pick out arguments in the right order, evaluating default expressions when an argument is not found.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The function <code>Core.kwftype(t)</code> fetches (and creates, if necessary) the field <code>t.name.mt.kwsorter</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This design has the feature that call sites that don&#39;t use keyword arguments require no special handling; everything works as if they were not part of the language at all. Call sites that do use keyword arguments are dispatched directly to the called function&#39;s kwsorter. For example the call:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">circle</span><span class="p">(</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="p">,</span><span> </span><span class="mf">1.0</span><span class="p">,</span><span> </span><span class="n">color</span><span> </span><span class="o">=</span><span> </span><span class="n">red</span><span class="p">;</span><span> </span><span class="n">other</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>is lowered to:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">kwfunc</span><span class="p">(</span><span class="n">circle</span><span class="p">)</span><span class="p">(</span><span class="kt">Any</span><span class="p">[</span><span class="p">:</span><span class="n">color</span><span class="p">,</span><span class="n">red</span><span class="p">,</span><span class="n">other</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="p">]</span><span class="p">,</span><span> </span><span class="n">circle</span><span class="p">,</span><span> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="p">,</span><span> </span><span class="mf">1.0</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The unpacking procedure represented here as <code>other...</code> actually further unpacks each <em>element</em> of <code>other</code>, expecting each one to contain two values (a symbol and a value). <code>kwfunc</code> (also in <code>Core</code>) fetches the kwsorter for the called function. Notice that the original <code>circle</code> function is passed through, to handle closures.</p><a id="Compiler-efficiency-issues-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Compiler efficiency issues</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Generating a new type for every function has potentially serious consequences for compiler resource use when combined with Julia&#39;s &quot;specialize on all arguments by default&quot; design. Indeed, the initial implementation of this design suffered from much longer build and test times, higher memory use, and a system image nearly 2x larger than the baseline. In a naive implementation, the problem is bad enough to make the system nearly unusable. Several significant optimizations were needed to make the design practical.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The first issue is excessive specialization of functions for different values of function-valued arguments. Many functions simply &quot;pass through&quot; an argument to somewhere else, e.g. to another function or to a storage location. Such functions do not need to be specialized for every closure that might be passed in. Fortunately this case is easy to distinguish by simply considering whether a function <em>calls</em> one of its arguments (i.e. the argument appears in &quot;head position&quot; somewhere). Performance-critical higher-order functions like <code>map</code> certainly call their argument function and so will still be specialized as expected. This optimization is implemented by recording which arguments are called during the <code>analyze-variables</code> pass in the front end. When <code>cache_method</code> sees an argument in the <code>Function</code> type hierarchy passed to a slot declared as <code>Any</code> or <code>Function</code>, it pretends the slot was declared as <code>ANY</code> (the &quot;don&#39;t specialize&quot; hint). This heuristic seems to be extremely effective in practice.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The next issue concerns the structure of method cache hash tables. Empirical studies show that the vast majority of dynamically-dispatched calls involve one or two arguments. In turn, many of these cases can be resolved by considering only the first argument. (Aside: proponents of single dispatch would not be surprised by this at all. However, this argument means &quot;multiple dispatch is easy to optimize in practice&quot;, and that we should therefore use it, <em>not</em> &quot;we should use single dispatch&quot;!) So the method cache uses the type of the first argument as its primary key. Note, however, that this corresponds to the <em>second</em> element of the tuple type for a function call (the first element being the type of the function itself). Typically, type variation in head position is extremely low – indeed, the majority of functions belong to singleton types with no parameters. However, this is not the case for constructors, where a single method table holds constructors for every type. Therefore the <code>Type</code> method table is special-cased to use the <em>first</em> tuple type element instead of the second.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The front end generates type declarations for all closures. Initially, this was implemented by generating normal type declarations. However, this produced an extremely large number of constructors, all of which were trivial (simply passing all arguments through to <code>new</code>). Since methods are partially ordered, inserting all of these methods is O(n^2), plus there are just too many of them to keep around. This was optimized by generating <code>composite_type</code> expressions directly (bypassing default constructor generation), and using <code>new</code> directly to create closure instances. Not the prettiest thing ever, but you do what you gotta do.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The next problem was the <code>@test</code> macro, which generated a 0-argument closure for each test case. This is not really necessary, since each test case is simply run once in place. Therefore I modified <code>@test</code> to expand to a try-catch block that records the test result (true, false, or exception raised) and calls the test suite handler on it.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>However this caused a new problem. When many tests are grouped together in a single function, e.g. a single top level expression, or some other test grouping function, that function could have a very large number of exception handlers. This triggered a kind of dataflow analysis worst case, where type inference spun around for minutes enumerating possible paths through the forest of handlers. This was fixed by simply bailing out of type inference when it encounters more than some number of handlers (currently 25). Presumably no performance-critical function will have more than 25 exception handlers. If one ever does, I&#39;m willing to raise the limit to 26.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A minor issue occurs during the bootstrap process due to storing all constructors in a single method table. In the second bootstrap step, where inference.ji is compiled using inference0.ji, constructors for inference0&#39;s types remain in the table, so there are still references to the old inference module and inference.ji is 2x the size it should be. This was fixed in dump.c by filtering definitions from &quot;replaced modules&quot; out of method tables and caches before saving a system image. A &quot;replaced module&quot; is one that satisfies the condition <code>m != jl_get_global(m-&gt;parent, m-&gt;name)</code> – in other words, some newer module has taken its name and place.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Another type inference worst case was triggered by the following code from quadgk.jl:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">do_quadgk</span><span class="p">{</span><span class="n">Tw</span><span class="p">}</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span> </span><span class="n">s</span><span class="p">,</span><span> </span><span class="n">n</span><span class="p">,</span><span> </span><span class="p">:</span><span class="p">:</span><span class="n">Type</span><span class="p">{</span><span class="n">Tw</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">abstol</span><span class="p">,</span><span> </span><span class="n">reltol</span><span class="p">,</span><span> </span><span class="n">maxevals</span><span class="p">,</span><span> </span><span class="n">nrm</span><span class="p">)</span><span>
</span><span>    </span><span class="k">if</span><span> </span><span class="n">eltype</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span> </span><span class="o">&lt;:</span><span> </span><span class="n">Real</span><span> </span><span class="c"># check for infinite or semi-infinite intervals</span><span>
</span><span>        </span><span class="n">s1</span><span> </span><span class="o">=</span><span> </span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="p">;</span><span> </span><span class="n">s2</span><span> </span><span class="o">=</span><span> </span><span class="n">s</span><span class="p">[</span><span class="k">end</span><span class="p">]</span><span class="p">;</span><span> </span><span class="n">inf1</span><span> </span><span class="o">=</span><span> </span><span class="n">isinf</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span><span class="p">;</span><span> </span><span class="n">inf2</span><span> </span><span class="o">=</span><span> </span><span class="n">isinf</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span><span>
</span><span>        </span><span class="k">if</span><span> </span><span class="n">inf1</span><span> </span><span class="o">||</span><span> </span><span class="n">inf2</span><span>
</span><span>            </span><span class="k">if</span><span> </span><span class="n">inf1</span><span> </span><span class="o">&amp;&amp;</span><span> </span><span class="n">inf2</span><span> </span><span class="c"># x = t/(1-t^2) coordinate transformation</span><span>
</span><span>                </span><span class="k">return</span><span> </span><span class="n">do_quadgk</span><span class="p">(</span><span class="n">t</span><span> </span><span class="o">-&gt;</span><span> </span><span class="k">begin</span><span> </span><span class="n">t2</span><span> </span><span class="o">=</span><span> </span><span class="n">t</span><span class="o">*</span><span class="n">t</span><span class="p">;</span><span> </span><span class="n">den</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span> </span><span class="o">/</span><span> </span><span class="p">(</span><span class="mi">1</span><span> </span><span class="o">-</span><span> </span><span class="n">t2</span><span class="p">)</span><span class="p">;</span><span>
</span><span>                                            </span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="o">*</span><span class="n">den</span><span class="p">)</span><span> </span><span class="o">*</span><span> </span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">t2</span><span class="p">)</span><span class="o">*</span><span class="n">den</span><span class="o">*</span><span class="n">den</span><span class="p">;</span><span> </span><span class="k">end</span><span class="p">,</span><span>
</span><span>                                 </span><span class="n">map</span><span class="p">(</span><span class="n">x</span><span> </span><span class="o">-&gt;</span><span> </span><span class="n">isinf</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span> </span><span class="o">?</span><span> </span><span class="n">copysign</span><span class="p">(</span><span class="n">one</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">x</span><span class="p">)</span><span> </span><span class="p">:</span><span> </span><span class="mi">2</span><span class="n">x</span><span> </span><span class="o">/</span><span> </span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">hypot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="n">x</span><span class="p">)</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">s</span><span class="p">)</span><span class="p">,</span><span>
</span><span>                                 </span><span class="n">n</span><span class="p">,</span><span> </span><span class="n">Tw</span><span class="p">,</span><span> </span><span class="n">abstol</span><span class="p">,</span><span> </span><span class="n">reltol</span><span class="p">,</span><span> </span><span class="n">maxevals</span><span class="p">,</span><span> </span><span class="n">nrm</span><span class="p">)</span><span>
</span><span>            </span><span class="k">end</span><span>
</span><span>            </span><span class="n">s0</span><span class="p">,</span><span class="n">si</span><span> </span><span class="o">=</span><span> </span><span class="n">inf1</span><span> </span><span class="o">?</span><span> </span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">s1</span><span class="p">)</span><span> </span><span class="p">:</span><span> </span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">)</span><span>
</span><span>            </span><span class="k">if</span><span> </span><span class="n">si</span><span> </span><span class="o">&lt;</span><span> </span><span class="mi">0</span><span> </span><span class="c"># x = s0 - t/(1-t)</span><span>
</span><span>                </span><span class="k">return</span><span> </span><span class="n">do_quadgk</span><span class="p">(</span><span class="n">t</span><span> </span><span class="o">-&gt;</span><span> </span><span class="k">begin</span><span> </span><span class="n">den</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span> </span><span class="o">/</span><span> </span><span class="p">(</span><span class="mi">1</span><span> </span><span class="o">-</span><span> </span><span class="n">t</span><span class="p">)</span><span class="p">;</span><span>
</span><span>                                            </span><span class="n">f</span><span class="p">(</span><span class="n">s0</span><span> </span><span class="o">-</span><span> </span><span class="n">t</span><span class="o">*</span><span class="n">den</span><span class="p">)</span><span> </span><span class="o">*</span><span> </span><span class="n">den</span><span class="o">*</span><span class="n">den</span><span class="p">;</span><span> </span><span class="k">end</span><span class="p">,</span><span>
</span><span>                                 </span><span class="n">reverse!</span><span class="p">(</span><span class="n">map</span><span class="p">(</span><span class="n">x</span><span> </span><span class="o">-&gt;</span><span> </span><span class="mi">1</span><span> </span><span class="o">/</span><span> </span><span class="p">(</span><span class="mi">1</span><span> </span><span class="o">+</span><span> </span><span class="mi">1</span><span> </span><span class="o">/</span><span> </span><span class="p">(</span><span class="n">s0</span><span> </span><span class="o">-</span><span> </span><span class="n">x</span><span class="p">)</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">s</span><span class="p">)</span><span class="p">)</span><span class="p">,</span><span>
</span><span>                                 </span><span class="n">n</span><span class="p">,</span><span> </span><span class="n">Tw</span><span class="p">,</span><span> </span><span class="n">abstol</span><span class="p">,</span><span> </span><span class="n">reltol</span><span class="p">,</span><span> </span><span class="n">maxevals</span><span class="p">,</span><span> </span><span class="n">nrm</span><span class="p">)</span><span>
</span><span>            </span><span class="k">else</span><span> </span><span class="c"># x = s0 + t/(1-t)</span><span>
</span><span>                </span><span class="k">return</span><span> </span><span class="n">do_quadgk</span><span class="p">(</span><span class="n">t</span><span> </span><span class="o">-&gt;</span><span> </span><span class="k">begin</span><span> </span><span class="n">den</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span> </span><span class="o">/</span><span> </span><span class="p">(</span><span class="mi">1</span><span> </span><span class="o">-</span><span> </span><span class="n">t</span><span class="p">)</span><span class="p">;</span><span>
</span><span>                                            </span><span class="n">f</span><span class="p">(</span><span class="n">s0</span><span> </span><span class="o">+</span><span> </span><span class="n">t</span><span class="o">*</span><span class="n">den</span><span class="p">)</span><span> </span><span class="o">*</span><span> </span><span class="n">den</span><span class="o">*</span><span class="n">den</span><span class="p">;</span><span> </span><span class="k">end</span><span class="p">,</span><span>
</span><span>                                 </span><span class="n">map</span><span class="p">(</span><span class="n">x</span><span> </span><span class="o">-&gt;</span><span> </span><span class="mi">1</span><span> </span><span class="o">/</span><span> </span><span class="p">(</span><span class="mi">1</span><span> </span><span class="o">+</span><span> </span><span class="mi">1</span><span> </span><span class="o">/</span><span> </span><span class="p">(</span><span class="n">x</span><span> </span><span class="o">-</span><span> </span><span class="n">s0</span><span class="p">)</span><span class="p">)</span><span class="p">,</span><span> </span><span class="n">s</span><span class="p">)</span><span class="p">,</span><span>
</span><span>                                 </span><span class="n">n</span><span class="p">,</span><span> </span><span class="n">Tw</span><span class="p">,</span><span> </span><span class="n">abstol</span><span class="p">,</span><span> </span><span class="n">reltol</span><span class="p">,</span><span> </span><span class="n">maxevals</span><span class="p">,</span><span> </span><span class="n">nrm</span><span class="p">)</span><span>
</span><span>            </span><span class="k">end</span><span>
</span><span>        </span><span class="k">end</span><span>
</span><span>    </span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This code has a 3-way tail recursion, where each call wraps the current function argument <code>f</code> in a different new closure. Inference must consider 3^n (where n is the call depth) possible signatures. This blows up way too quickly, so logic was added to typeinf_uncached to immediately widen any argument that is a subtype of <code>Function</code> and that grows in depth down the stack.</p><footer><hr/><a class="previous" href="eval.html"><span class="direction">Previous</span><span class="title">Eval of Julia code</span></a><a class="next" href="init.html"><span class="direction">Next</span><span class="title">Initialization of the Julia runtime</span></a></footer></article></body></html>
