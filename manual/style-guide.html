<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documenter.jl</title><link href="../normalize.css" rel="stylesheet" type="text/css"/><link href="../style.css" rel="stylesheet" type="text/css"/><link href="../highlight.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="../require.js" data-main="../documenter.js"></script><script src="../search-index.js"></script></head><body><nav class="toc"><a href="http://julialang.org/"><img class="logo" src="http://docs.julialang.org/en/release-0.4/_static/julia-logo.svg" alt="\$pkgname.jl logo"/></a><h1>$pkgname.jl</h1><input type="text" placeholder="Search docs"/><ul><li><a class="toctext" href="../index.html">Overview</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/guide.html">Guide</a></li><li><a class="toctext" href="../man/examples.html">Examples</a></li><li><a class="toctext" href="../man/syntax.html">Syntax</a></li><li><a class="toctext" href="../man/doctests.html">Doctests</a></li><li><a class="toctext" href="../man/hosting.html">Hosting Documentation</a></li><li><a class="toctext" href="../man/latex.html"><span>$\LaTeX$</span> syntax</a></li><li><a class="toctext" href="../man/internals.html">Package Internals</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../lib/public.html">Public Documentation</a></li><li><a class="toctext" href="../lib/internals.html">Internal Documentation</a></li></ul></li><li><span class="toctext">Dynamic pages</span><ul><li><a class="toctext" href="../dynamic/code.html">Code examples</a></li><li><a class="toctext" href="../dynamic/admonitions.html">Admonitions &amp; Co</a></li><li><a class="toctext" href="../dynamic/styles.html">Demonstrating <em>styles</em> of MD elements</a></li><li><a class="toctext" href="../dynamic/bugs.html">Some existing bugs</a></li></ul></li><li><span class="toctext">JuliaDocs - Manual</span><ul><li><a class="toctext" href="arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="constructors.html">Constructors</a></li><li><a class="toctext" href="control-flow.html">Control Flow</a></li><li><a class="toctext" href="conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="dates.html">Date and DateTime</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="functions.html">Functions</a></li><li><a class="toctext" href="getting-started.html">Getting Started</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="index.html">The Julia Manual</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="introduction.html">Introduction</a></li><li><a class="toctext" href="linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="methods.html">Methods</a></li><li><a class="toctext" href="modules.html">Modules</a></li><li><a class="toctext" href="networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="packages.html">Packages</a></li><li><a class="toctext" href="parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li class="current"><a class="toctext" href="style-guide.html">Style Guide</a><ul class="internal"><li><a class="toctext" href="#Write-functions,-not-just-scripts-1">Write functions, not just scripts</a></li><li><a class="toctext" href="#Avoid-writing-overly-specific-types-1">Avoid writing overly-specific types</a></li><li><a class="toctext" href="#Handle-excess-argument-diversity-in-the-caller-1">Handle excess argument diversity in the caller</a></li><li><a class="toctext" href="#Append-!-to-names-of-functions-that-modify-their-arguments-1">Append <code>!</code> to names of functions that modify their arguments</a></li><li><a class="toctext" href="#Avoid-strange-type-Unions-1">Avoid strange type Unions</a></li><li><a class="toctext" href="#Avoid-type-Unions-in-fields-1">Avoid type Unions in fields</a></li><li><a class="toctext" href="#Avoid-elaborate-container-types-1">Avoid elaborate container types</a></li><li><a class="toctext" href="#Use-naming-conventions-consistent-with-Julia's-base/-1">Use naming conventions consistent with Julia&#39;s <code>base/</code></a></li><li><a class="toctext" href="#Don't-overuse-try-catch-1">Don&#39;t overuse try-catch</a></li><li><a class="toctext" href="#Don't-parenthesize-conditions-1">Don&#39;t parenthesize conditions</a></li><li><a class="toctext" href="#Don't-overuse-...-1">Don&#39;t overuse ...</a></li><li><a class="toctext" href="#Don't-use-unnecessary-static-parameters-1">Don&#39;t use unnecessary static parameters</a></li><li><a class="toctext" href="#Avoid-confusion-about-whether-something-is-an-instance-or-a-type-1">Avoid confusion about whether something is an instance or a type</a></li><li><a class="toctext" href="#Don't-overuse-macros-1">Don&#39;t overuse macros</a></li><li><a class="toctext" href="#Don't-expose-unsafe-operations-at-the-interface-level-1">Don&#39;t expose unsafe operations at the interface level</a></li><li><a class="toctext" href="#Don't-overload-methods-of-base-container-types-1">Don&#39;t overload methods of base container types</a></li><li><a class="toctext" href="#Be-careful-with-type-equality-1">Be careful with type equality</a></li><li><a class="toctext" href="#Do-not-write-x-f(x)-1">Do not write <code>x-&gt;f(x)</code></a></li><li><a class="toctext" href="#Avoid-using-floats-for-numeric-literals-in-generic-code-when-possible-1">Avoid using floats for numeric literals in generic code when possible</a></li></ul></li><li><a class="toctext" href="types.html">Types</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li><li><a class="toctext" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="variables.html">Variables</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li></ul></li><li><span class="toctext">JuliaDocs - Standard Libary</span><ul><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/c.html">C Interface</a></li><li><a class="toctext" href="../stdlib/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../stdlib/constants.html">Constants</a></li><li><a class="toctext" href="../stdlib/dates.html">Dates and Time</a></li><li><a class="toctext" href="../stdlib/file.html">Filesystem</a></li><li><a class="toctext" href="../stdlib/index.html">The Julia Standard Library</a></li><li><a class="toctext" href="../stdlib/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../stdlib/libc.html">C Standard Library</a></li><li><a class="toctext" href="../stdlib/libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/linalg.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/math.html">Mathematics</a></li><li><a class="toctext" href="../stdlib/numbers.html">Numbers</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="../stdlib/pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../stdlib/simd-types.html">SIMD Support</a></li><li><a class="toctext" href="../stdlib/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../stdlib/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../stdlib/strings.html">Strings</a></li><li><a class="toctext" href="../stdlib/test.html">Unit Testing</a></li></ul></li><li><span class="toctext">JuliaDocs - DevDocs</span><ul><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/C.html">Developing/debugging Julia&#39;s C code</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/julia.html">Documentation of Julia&#39;s Internals</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/promote-op.html">Operator-sensitive promotion</a></li><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>JuliaDocs - Manual</li><li><a href="style-guide.html">Style Guide</a></li></ul><a class="edit-page" href="https://github.com/"><span class="fa">ï‚›</span> Edit on GitHub</a></nav><hr/></header><a id="Style-Guide-1"></a><div class="mdnote debug">Base.Markdown.Header{1}</div><h1>Style Guide</h1><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The following sections explain a few aspects of idiomatic Julia coding style. None of these rules are absolute; they are only suggestions to help familiarize you with the language and to help you choose among alternative designs.</p><a id="Write-functions,-not-just-scripts-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Write functions, not just scripts</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Writing code as a series of steps at the top level is a quick way to get started solving a problem, but you should try to divide a program into functions as soon as possible. Functions are more reusable and testable, and clarify what steps are being done and what their inputs and outputs are. Furthermore, code inside functions tends to run much faster than top level code, due to how Julia&#39;s compiler works.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>It is also worth emphasizing that functions should take arguments, instead of operating directly on global variables (aside from constants like <a href="../stdlib/numbers.html#Base.pi"><code>pi</code></a>).</p><a id="Avoid-writing-overly-specific-types-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Avoid writing overly-specific types</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Code should be as generic as possible. Instead of writing:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="nb">convert</span><span class="p">(</span><span class="n">Complex</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">x</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>it&#39;s better to use available generic functions:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">complex</span><span class="p">(</span><span class="n">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The second version will convert <code>x</code> to an appropriate type, instead of always the same type.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This style point is especially relevant to function arguments. For example, don&#39;t declare an argument to be of type <code>Int</code> or <code>Int32</code> if it really could be any integer, expressed with the abstract type <code>Integer</code>.  In fact, in many cases you can omit the argument type altogether, unless it is needed to disambiguate from other method definitions, since a <a href="../stdlib/base.html#Base.MethodError"><code>MethodError</code></a> will be thrown anyway if a type is passed that does not support any of the requisite operations. (This is known as <a href="https://en.wikipedia.org/wiki/Duck_typing">duck typing</a>.)</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For example, consider the following definitions of a function <code>addone</code> that returns one plus its argument:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">addone</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="kt">Int</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">x</span><span> </span><span class="o">+</span><span> </span><span class="mi">1</span><span>             </span><span class="c"># works only for Int</span><span>
</span><span class="n">addone</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">Integer</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">x</span><span> </span><span class="o">+</span><span> </span><span class="n">one</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span>    </span><span class="c"># any integer type</span><span>
</span><span class="n">addone</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">Number</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">x</span><span> </span><span class="o">+</span><span> </span><span class="n">one</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span>     </span><span class="c"># any numeric type</span><span>
</span><span class="n">addone</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">x</span><span> </span><span class="o">+</span><span> </span><span class="n">one</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span>             </span><span class="c"># any type supporting + and one</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The last definition of <code>addone</code> handles any type supporting <a href="../stdlib/numbers.html#Base.one"><code>one()</code></a> (which returns 1 in the same type as <code>x</code>, which avoids unwanted type promotion) and the <a href="../stdlib/math.html#Base.+"><code>+</code></a> function with those arguments.  The key thing to realize is that there is <em>no performance penalty</em> to defining <em>only</em> the general <code>addone(x) = x + one(x)</code>, because Julia will automatically compile specialized versions as needed.  For example, the first time you call <code>addone(12)</code>, Julia will automatically compile a specialized <code>addone</code> function for <code>x::Int</code> arguments, with the call to <a href="../stdlib/numbers.html#Base.one"><code>one()</code></a> replaced by its inlined value <code>1</code>.  Therefore, the first three definitions of <code>addone</code> above are completely redundant.</p><a id="Handle-excess-argument-diversity-in-the-caller-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Handle excess argument diversity in the caller</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Instead of:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">function foo(x, y)
    x = Int(x); y = Int(y)
    ...
end
foo(x, y)</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>use:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">function foo(x::Int, y::Int)
    ...
end
foo(Int(x), Int(y))</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This is better style because <code>foo</code> does not really accept numbers of all types; it really needs <code>Int</code> s.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>One issue here is that if a function inherently requires integers, it might be better to force the caller to decide how non-integers should be converted (e.g. floor or ceiling). Another issue is that declaring more specific types leaves more &quot;space&quot; for future method definitions.</p><a id="Append-!-to-names-of-functions-that-modify-their-arguments-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Append <code>!</code> to names of functions that modify their arguments</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Instead of:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">double</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Number</span><span class="p">}</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="p">:</span><span class="n">AbstractArray</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">)</span><span>
</span><span>    </span><span class="k">for</span><span> </span><span class="n">i</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span class="p">:</span><span class="n">endof</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="p">;</span><span> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span> </span><span class="o">*</span><span class="o">=</span><span> </span><span class="mi">2</span><span class="p">;</span><span> </span><span class="k">end</span><span>
</span><span>    </span><span class="n">a</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>use:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">double</span><span class="o">!</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Number</span><span class="p">}</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="p">:</span><span class="n">AbstractArray</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">)</span><span>
</span><span>    </span><span class="k">for</span><span> </span><span class="n">i</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span class="p">:</span><span class="n">endof</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="p">;</span><span> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span> </span><span class="o">*</span><span class="o">=</span><span> </span><span class="mi">2</span><span class="p">;</span><span> </span><span class="k">end</span><span>
</span><span>    </span><span class="n">a</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The Julia standard library uses this convention throughout and contains examples of functions with both copying and modifying forms (e.g., <a href="../stdlib/sort.html#Base.sort"><code>sort()</code></a> and <a href="../stdlib/sort.html#Base.sort!"><code>sort!()</code></a>), and others which are just modifying (e.g., <a href="../stdlib/collections.html#Base.push!"><code>push!()</code></a>, <a href="../stdlib/collections.html#Base.pop!"><code>pop!()</code></a>, <a href="../stdlib/collections.html#Base.splice!"><code>splice!()</code></a>).  It is typical for such functions to also return the modified array for convenience.</p><a id="Avoid-strange-type-Unions-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Avoid strange type Unions</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Types such as <code>Union{Function,AbstractString}</code> are often a sign that some design could be cleaner.</p><a id="Avoid-type-Unions-in-fields-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Avoid type Unions in fields</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>When creating a type such as:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">type MyType
    ...
    x::Union{Void,T}
end</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>ask whether the option for <code>x</code> to be <code>nothing</code> (of type <code>Void</code>) is really necessary. Here are some alternatives to consider:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>Find a safe default value to initialize <code>x</code> with</p></li><li><p>Introduce another type that lacks <code>x</code></p></li><li><p>If there are many fields like <code>x</code>, store them in a dictionary</p></li><li><p>Determine whether there is a simple rule for when <code>x</code> is <code>nothing</code>. For example, often the field will start as <code>nothing</code> but get initialized at some well-defined point. In that case, consider leaving it undefined at first.</p></li><li><p>If <code>x</code> really needs to hold no value at some times, define it as <code>::Nullable{T}</code> instead, as this guarantees type-stability in the code accessing this field (see <a href="@ref">Nullable types</a>)</p></li></ul><a id="Avoid-elaborate-container-types-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Avoid elaborate container types</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>It is usually not much help to construct arrays like the following:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">a</span><span> </span><span class="o">=</span><span> </span><span class="n">Array</span><span class="p">{</span><span class="n">Union</span><span class="p">{</span><span class="kt">Int</span><span class="p">,</span><span class="n">AbstractString</span><span class="p">,</span><span class="n">Tuple</span><span class="p">,</span><span class="n">Array</span><span class="p">}</span><span class="p">}</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In this case <code>Array{Any}(n)</code> is better. It is also more helpful to the compiler to annotate specific uses (e.g. <code>a[i]::Int</code>) than to try to pack many alternatives into one type.</p><a id="Use-naming-conventions-consistent-with-Julia's-base/-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Use naming conventions consistent with Julia&#39;s <code>base/</code></h2><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>modules and type names use capitalization and camel case: <code>module SparseArrays</code>,  <code>immutable UnitRange</code>.</p></li><li><p>functions are lowercase (<a href="../stdlib/collections.html#Base.maximum"><code>maximum()</code></a>, <a href="../stdlib/base.html#Base.convert"><code>convert()</code></a>) and, when readable, with multiple words squashed together (<a href="../stdlib/base.html#Base.isequal"><code>isequal()</code></a>, <a href="../stdlib/collections.html#Base.haskey"><code>haskey()</code></a>). When necessary, use underscores as word separators. Underscores are also used to indicate a combination of concepts (<a href="../stdlib/parallel.html#Base.remotecall_fetch"><code>remotecall_fetch()</code></a> as a more efficient implementation of <code>fetch(remotecall(...))</code>) or as modifiers (<a href="../stdlib/arrays.html#Base.sum_kbn"><code>sum_kbn()</code></a>).</p></li><li><p>conciseness is valued, but avoid abbreviation (<a href="../stdlib/collections.html#Base.indexin"><code>indexin()</code></a> rather than <code>indxin()</code>) as it becomes difficult to remember whether and how particular words are abbreviated.</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If a function name requires multiple words, consider whether it might represent more than one concept and might be better split into pieces.</p><a id="Don't-overuse-try-catch-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Don&#39;t overuse try-catch</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>It is better to avoid errors than to rely on catching them.</p><a id="Don't-parenthesize-conditions-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Don&#39;t parenthesize conditions</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia doesn&#39;t require parens around conditions in <code>if</code> and <code>while</code>. Write:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">if</span><span> </span><span class="n">a</span><span> </span><span class="o">==</span><span> </span><span class="n">b</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>instead of:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">if</span><span> </span><span class="p">(</span><span class="n">a</span><span> </span><span class="o">==</span><span> </span><span class="n">b</span><span class="p">)</span><span>
</span></code></pre><a id="Don't-overuse-...-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Don&#39;t overuse ...</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Splicing function arguments can be addictive. Instead of <code>[a..., b...]</code>, use simply <code>[a; b]</code>, which already concatenates arrays. <a href="../stdlib/collections.html#Base.collect"><code>collect(a)</code></a> is better than <code>[a...]</code>, but since <code>a</code> is already iterable it is often even better to leave it alone, and not convert it to an array.</p><a id="Don't-use-unnecessary-static-parameters-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Don&#39;t use unnecessary static parameters</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A function signature:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">foo{T&lt;:Real}(x::T) = ...</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>should be written as:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">foo(x::Real) = ...</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>instead, especially if <code>T</code> is not used in the function body. Even if <code>T</code> is used, it can be replaced with <a href="../stdlib/base.html#Core.typeof"><code>typeof(x)</code></a> if convenient. There is no performance difference. Note that this is not a general caution against static parameters, just against uses where they are not needed.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Note also that container types, specifically may need type parameters in function calls. See the FAQ <a href="performance-tips.html#Avoid-fields-with-abstract-containers-1">Avoid fields with abstract containers</a> for more information.</p><a id="Avoid-confusion-about-whether-something-is-an-instance-or-a-type-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Avoid confusion about whether something is an instance or a type</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Sets of definitions like the following are confusing:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">foo(::Type{MyType}) = ...
foo(::MyType) = foo(MyType)</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Decide whether the concept in question will be written as <code>MyType</code> or <code>MyType()</code>, and stick to it.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The preferred style is to use instances by default, and only add methods involving <code>Type{MyType}</code> later if they become necessary to solve some problem.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If a type is effectively an enumeration, it should be defined as a single (ideally <code>immutable</code>) type, with the enumeration values being instances of it. Constructors and conversions can check whether values are valid. This design is preferred over making the enumeration an abstract type, with the &quot;values&quot; as subtypes.</p><a id="Don't-overuse-macros-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Don&#39;t overuse macros</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Be aware of when a macro could really be a function instead.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Calling <a href="@ref"><code>eval()</code></a> inside a macro is a particularly dangerous warning sign; it means the macro will only work when called at the top level. If such a macro is written as a function instead, it will naturally have access to the run-time values it needs.</p><a id="Don't-expose-unsafe-operations-at-the-interface-level-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Don&#39;t expose unsafe operations at the interface level</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If you have a type that uses a native pointer:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">type NativeType
    p::Ptr{UInt8}
    ...
end</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>don&#39;t write definitions like the following:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">getindex</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">NativeType</span><span class="p">,</span><span> </span><span class="n">i</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">unsafe_load</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">p</span><span class="p">,</span><span> </span><span class="n">i</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The problem is that users of this type can write <code>x[i]</code> without realizing that the operation is unsafe, and then be susceptible to memory bugs.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Such a function should either check the operation to ensure it is safe, or have <code>unsafe</code> somewhere in its name to alert callers.</p><a id="Don't-overload-methods-of-base-container-types-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Don&#39;t overload methods of base container types</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>It is possible to write definitions like the following:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">show(io::IO, v::Vector{MyType}) = ...</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This would provide custom showing of vectors with a specific new element type. While tempting, this should be avoided. The trouble is that users will expect a well-known type like <code>Vector()</code> to behave in a certain way, and overly customizing its behavior can make it harder to work with.</p><a id="Be-careful-with-type-equality-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Be careful with type equality</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>You generally want to use <a href="../stdlib/base.html#Core.isa"><code>isa()</code></a> and <code>&lt;:</code> (<a href="../stdlib/base.html#Core.issubtype"><code>issubtype()</code></a>) for testing types, not <code>==</code>. Checking types for exact equality typically only makes sense when comparing to a known concrete type (e.g. <code>T == Float64</code>), or if you <em>really, really</em> know what you&#39;re doing.</p><a id="Do-not-write-x-f(x)-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Do not write <code>x-&gt;f(x)</code></h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Since higher-order functions are often called with anonymous functions, it is easy to conclude that this is desirable or even necessary. But any function can be passed directly, without being &quot;wrapped&quot; in an anonymous function. Instead of writing <code>map(x-&gt;f(x), a)</code>, write <a href="../stdlib/collections.html#Base.map"><code>map(f, a)</code></a>.</p><a id="Avoid-using-floats-for-numeric-literals-in-generic-code-when-possible-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Avoid using floats for numeric literals in generic code when possible</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If you write generic code which handles numbers, and which can be expected to run with many different numeric type arguments, try using literals of a numeric type that will affect the arguments as little as possible through promotion.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For example,</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mf">2.0</span><span> </span><span class="o">*</span><span> </span><span class="n">x</span><span>
</span><span class="go">f (generic function with 1 method)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span>
</span><span class="go">1.0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span>
</span><span class="go">1.0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span>
</span><span class="go">2.0
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>while</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">2</span><span> </span><span class="o">*</span><span> </span><span class="n">x</span><span>
</span><span class="go">g (generic function with 1 method)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span>
</span><span class="go">1//1
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span>
</span><span class="go">1.0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">g</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span>
</span><span class="go">4
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>As you can see, the second version, where we used an <code>Int</code> literal, preserved the type of the input argument, while the first didn&#39;t. This is because e.g. <code>promote_type(Int, Float64) == Float64</code>, and promotion happens with the multiplication. Similarly, <code>Rational</code> literals are less type disruptive than <a href="../stdlib/numbers.html#Core.Float64"><code>Float64</code></a> literals, but more disruptive than <code>Int</code>s:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">2</span><span class="o">/</span><span class="o">/</span><span class="mi">1</span><span> </span><span class="o">*</span><span> </span><span class="n">x</span><span>
</span><span class="go">h (generic function with 1 method)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">h</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span>
</span><span class="go">1//1
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">h</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span>
</span><span class="go">1.0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">h</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span>
</span><span class="go">2//1
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Thus, use <code>Int</code> literals when possible, with <code>Rational{Int}</code> for literal non-integer numbers, in order to make it easier to use your code.</p><footer><hr/><a class="previous" href="strings.html"><span class="direction">Previous</span><span class="title">Strings</span></a><a class="next" href="types.html"><span class="direction">Next</span><span class="title">Types</span></a></footer></article></body></html>
