<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documenter.jl</title><link href="../normalize.css" rel="stylesheet" type="text/css"/><link href="../style.css" rel="stylesheet" type="text/css"/><link href="../highlight.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="../require.js" data-main="../documenter.js"></script><script src="../search-index.js"></script></head><body><nav class="toc"><a href="http://julialang.org/"><img class="logo" src="http://docs.julialang.org/en/release-0.4/_static/julia-logo.svg" alt="\$pkgname.jl logo"/></a><h1>$pkgname.jl</h1><input type="text" placeholder="Search docs"/><ul><li><a class="toctext" href="../index.html">Overview</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/guide.html">Guide</a></li><li><a class="toctext" href="../man/examples.html">Examples</a></li><li><a class="toctext" href="../man/syntax.html">Syntax</a></li><li><a class="toctext" href="../man/doctests.html">Doctests</a></li><li><a class="toctext" href="../man/hosting.html">Hosting Documentation</a></li><li><a class="toctext" href="../man/latex.html"><span>$\LaTeX$</span> syntax</a></li><li><a class="toctext" href="../man/internals.html">Package Internals</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../lib/public.html">Public Documentation</a></li><li><a class="toctext" href="../lib/internals.html">Internal Documentation</a></li></ul></li><li><span class="toctext">Dynamic pages</span><ul><li><a class="toctext" href="../dynamic/code.html">Code examples</a></li><li><a class="toctext" href="../dynamic/admonitions.html">Admonitions &amp; Co</a></li><li><a class="toctext" href="../dynamic/styles.html">Demonstrating <em>styles</em> of MD elements</a></li><li><a class="toctext" href="../dynamic/bugs.html">Some existing bugs</a></li></ul></li><li><span class="toctext">JuliaDocs - Manual</span><ul><li><a class="toctext" href="arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="constructors.html">Constructors</a></li><li><a class="toctext" href="control-flow.html">Control Flow</a></li><li><a class="toctext" href="conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="dates.html">Date and DateTime</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="functions.html">Functions</a></li><li><a class="toctext" href="getting-started.html">Getting Started</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="index.html">The Julia Manual</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="introduction.html">Introduction</a></li><li><a class="toctext" href="linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="methods.html">Methods</a></li><li><a class="toctext" href="modules.html">Modules</a></li><li><a class="toctext" href="networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="packages.html">Packages</a></li><li><a class="toctext" href="parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="style-guide.html">Style Guide</a></li><li><a class="toctext" href="types.html">Types</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li><li class="current"><a class="toctext" href="variables-and-scoping.html">Scope of Variables</a><ul class="internal"><li><a class="toctext" href="#Global-Scope-1">Global Scope</a></li><li><a class="toctext" href="#Local-Scope-1">Local Scope</a></li><li><a class="toctext" href="#Constants-1">Constants</a></li></ul></li><li><a class="toctext" href="variables.html">Variables</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li></ul></li><li><span class="toctext">JuliaDocs - Standard Libary</span><ul><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/c.html">C Interface</a></li><li><a class="toctext" href="../stdlib/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../stdlib/constants.html">Constants</a></li><li><a class="toctext" href="../stdlib/dates.html">Dates and Time</a></li><li><a class="toctext" href="../stdlib/file.html">Filesystem</a></li><li><a class="toctext" href="../stdlib/index.html">The Julia Standard Library</a></li><li><a class="toctext" href="../stdlib/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../stdlib/libc.html">C Standard Library</a></li><li><a class="toctext" href="../stdlib/libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/linalg.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/math.html">Mathematics</a></li><li><a class="toctext" href="../stdlib/numbers.html">Numbers</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="../stdlib/pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../stdlib/simd-types.html">SIMD Support</a></li><li><a class="toctext" href="../stdlib/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../stdlib/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../stdlib/strings.html">Strings</a></li><li><a class="toctext" href="../stdlib/test.html">Unit Testing</a></li></ul></li><li><span class="toctext">JuliaDocs - DevDocs</span><ul><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/C.html">Developing/debugging Julia&#39;s C code</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/julia.html">Documentation of Julia&#39;s Internals</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/promote-op.html">Operator-sensitive promotion</a></li><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>JuliaDocs - Manual</li><li><a href="variables-and-scoping.html">Scope of Variables</a></li></ul><a class="edit-page" href="https://github.com/"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><a id="Scope-of-Variables-1"></a><div class="mdnote debug">Base.Markdown.Header{1}</div><h1>Scope of Variables</h1><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The <em>scope</em> of a variable is the region of code within which a variable is visible. Variable scoping helps avoid variable naming conflicts. The concept is intuitive: two functions can both have arguments called <code>x</code> without the two <code>x</code>&#39;s referring to the same thing. Similarly there are many other cases where different blocks of code can use the same name without referring to the same thing. The rules for when the same variable name does or doesn&#39;t refer to the same thing are called scope rules; this section spells them out in detail.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Certain constructs in the language introduce <em>scope blocks</em>, which are regions of code that are eligible to be the scope of some set of variables. The scope of a variable cannot be an arbitrary set of source lines; instead, it will always line up with one of these blocks.  There are two main types of scopes in Julia, <em>global scope</em> and <em>local scope</em>, the latter can be nested.  The constructs introducing scope blocks are:</p><div class="mdnote debug">Base.Markdown.Table</div><table><tr><th>Scope name</th><th>block/construct introducing this kind of scope</th></tr><tr><td><a href="@ref">global</a></td><td><code>module</code>, <code>baremodule</code>, at interactive prompt (REPL)</td></tr><tr><td><a href="@ref">local</a></td><td><a href="@ref">soft</a>: <code>for</code>, <code>while</code>, comprehensions, try-catch-finally, <code>let</code></td></tr><tr><td><a href="@ref">local</a></td><td><a href="@ref">hard</a>: functions (either syntax, anonymous &amp; do-blocks), <code>type</code>, <code>immutable</code>, <code>macro</code></td></tr></table><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Notably missing from this table are <a href="@ref">begin blocks</a> and <a href="@ref">if blocks</a>, which do <em>not</em> introduce new scope blocks.  All three types of scopes follow somewhat different rules which will be explained below as well as some extra rules for certain blocks.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia uses <a href="https://en.wikipedia.org/wiki/Scope_%28computer_science%29#Lexical_scoping_vs._dynamic_scoping">lexical scoping</a>, meaning that a function&#39;s scope does not inherit from its caller&#39;s scope, but from the scope in which the function was defined. For example, in the following code the <code>x</code> inside <code>foo</code> refers to the <code>x</code> in the global scope of its module <code>Bar</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">module</span><span> </span><span class="n">Bar</span><span>
</span><span class="n">x</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span>
</span><span class="n">foo</span><span class="p">(</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">x</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>and not a <code>x</code> in the scope where <code>foo</code> is used:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="k">import</span><span> </span><span class="n">Bar</span><span>
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x</span><span> </span><span class="o">=</span><span> </span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span>
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Bar</span><span class="o">.</span><span class="n">foo</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="go">1
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Thus <em>lexical scope</em> means that the scope of variables can be inferred from the source code alone.</p><a id="Global-Scope-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Global Scope</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p><em>Each module introduces a new global scope</em>, separate from the global scope of all other modules; there is no all-encompassing global scope. Modules can introduce variables of other modules into their scope through the <a href="@ref">using or import</a> statements or through qualified access using the dot-notation, i.e. each module is a so-called <em>namespace</em>.  Note that variable bindings can only be changed within their global scope and not from an outside module.</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">module</span><span> </span><span class="n">A</span><span>
</span><span class="n">a</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span> </span><span class="c"># a global in A&#39;s scope</span><span>
</span><span class="k">end</span><span>
</span><span>
</span><span class="k">module</span><span> </span><span class="n">B</span><span>
</span><span class="c"># b = a # would error as B&#39;s global scope is separate from A&#39;s</span><span>
</span><span>    </span><span class="k">module</span><span> </span><span class="n">C</span><span>
</span><span>    </span><span class="n">c</span><span> </span><span class="o">=</span><span> </span><span class="mi">2</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span class="n">b</span><span> </span><span class="o">=</span><span> </span><span class="n">C</span><span class="o">.</span><span class="n">c</span><span> </span><span class="c"># can access the namespace of a nested global scope</span><span>
</span><span>        </span><span class="c"># through a qualified access</span><span>
</span><span class="k">import</span><span> </span><span class="n">A</span><span> </span><span class="c"># makes module A available</span><span>
</span><span class="n">d</span><span> </span><span class="o">=</span><span> </span><span class="n">A</span><span class="o">.</span><span class="n">a</span><span>
</span><span class="c"># A.a = 2 # would error with: &quot;ERROR: cannot assign variables in other modules&quot;</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Note that the interactive prompt (aka REPL) is in the global scope of the module <code>Main</code>.</p><a id="Local-Scope-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Local Scope</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A new local scope is introduced by most code-blocks, see above <a href="@ref">table</a> for a complete list.  A local scope <em>usually</em> inherits all the variables from its parent scope, both for reading and writing.  There are two subtypes of local scopes, hard and soft, with slightly different rules concerning what variables are inherited.  Unlike global scopes, local scopes are not namespaces, thus variables in an inner scope cannot be retrieved from the parent scope through some sort of qualified access.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The following rules and examples pertain to both hard and soft local scopes.  A newly introduced variable in a local scope does not back-propagate to its parent scope.  For example, here the <code>z</code> is not introduced into the top-level scope:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">for i=1:10
</span><span class="go">    z = i
</span><span class="go">end
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">z</span><span>
</span><span class="go">ERROR: UndefVarError: z not defined
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>(Note, in this and all following examples it is assumed that their top-level is a global scope with a clean workspace, for instance a newly started REPL.)</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Inside a local scope a variable can be forced to be a local variable using the <code>local</code> keyword:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">x = 0
</span><span class="go">for i=1:10
</span><span class="go">    local x
</span><span class="go">    x = i + 1
</span><span class="go">end
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x</span><span>
</span><span class="go">0
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Inside a local scope a new global variable can be defined using the keyword <code>global</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">for i=1:10
</span><span class="go">    global z
</span><span class="go">    z = i
</span><span class="go">end
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">z</span><span>
</span><span class="go">10
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The location of both the <code>local</code> and <code>global</code> keywords within the scope block is irrelevant.  The following is equivalent to the last example (although stylistically worse):</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">for i=1:10
</span><span class="go">    z = i
</span><span class="go">    global z
</span><span class="go">end
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">z</span><span>
</span><span class="go">10
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Multiple global or local definitions can be on one line and can also be paired with assignments:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">for</span><span> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span>
</span><span>    </span><span class="kd">global</span><span> </span><span class="n">x</span><span class="o">=</span><span class="n">i</span><span class="p">,</span><span> </span><span class="n">y</span><span class="p">,</span><span> </span><span class="n">z</span><span>
</span><span>    </span><span class="kd">local</span><span> </span><span class="n">a</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span><span> </span><span class="n">b</span><span> </span><span class="p">,</span><span> </span><span class="n">c</span><span class="o">=</span><span class="mi">1</span><span>
</span><span class="k">end</span><span>
</span></code></pre><a id="Soft-Local-Scope-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Soft Local Scope</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Soft local scopes are introduced by for-loops, while-loops, comprehensions, try-catch-finally-blocks, and let-blocks.  There are some extra rules for <a href="@ref">let-blocks</a> and for <a href="@ref">for-loops and comprehensions</a>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In the following example the <code>x</code> and <code>y</code> refer always to the same variables as the soft local scope inherits both read and write variables:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">x,y = 0, 1
</span><span class="go">for i = 1:10
</span><span class="go">    x = i + y + 1
</span><span class="go">end
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x</span><span>
</span><span class="go">12
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Within soft scopes, the <em>global</em> keyword is never necessary, although allowed.  The only case when it would change the semantics is (currently) a syntax error:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">let</span><span>
</span><span>    </span><span class="kd">local</span><span> </span><span class="n">x</span><span> </span><span class="o">=</span><span> </span><span class="mi">2</span><span>
</span><span>    </span><span class="k">let</span><span>
</span><span>        </span><span class="kd">global</span><span> </span><span class="n">x</span><span> </span><span class="o">=</span><span> </span><span class="mi">3</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span class="k">end</span><span>
</span><span>
</span><span class="c"># ERROR: syntax: `global x`: x is local variable in the enclosing scope</span><span>
</span></code></pre><a id="Hard-Local-Scope-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Hard Local Scope</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Hard local scopes are introduced by function definitions (in all their forms), type &amp; immutable-blocks, and macro-definitions.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In a hard local scope, all variables are inherited from its parent scope unless:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>an assignment would result in a modified <em>global</em> variable, or</p></li><li><p>a variable is specifically marked with the keyword <code>local</code>.</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Thus global variables are only inherited for reading but not for writing:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">x,y = 1,2
</span><span class="go">function foo()
</span><span class="go">    x = 2 # assignment introduces a new local
</span><span class="go">    return x + y # y refers to the global
</span><span class="go">end
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">foo</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="go">4
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x</span><span>
</span><span class="go">1
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>An explicit <code>global</code> is needed to assign to a global variable:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">x = 1
</span><span class="go">function foo()
</span><span class="go">    global x = 2
</span><span class="go">end
</span><span class="go">foo()
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x</span><span>
</span><span class="go">2
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Note that <em>nested functions</em> can behave differently to functions defined in the global scope as they can modify their parent scope&#39;s <em>local</em> variables:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">x,y = 1,2
</span><span class="go">function foo()
</span><span class="go">    x = 2 # introduces a new local
</span><span class="go">    function bar()
</span><span class="go">    end
</span><span class="go">    return bar() + x # 12 + 10 (x is modified in call of bar())
</span><span class="go">end
</span><span class="go">
</span><span></span><span class="gt">
        x = 10 # modifies the parent&#39;s x
</span><span></span><span class="gt">
        return x+y # y is global
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">foo</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="go">22  # (x,y unchanged)
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The distinction between inheriting global and local variables for assignment can lead to some slight differences between functions defined in local vs. global scopes.  Consider the modification of the last example by moving <code>bar</code> to the global scope:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">x,y = 1,2
</span><span class="go">function bar()
</span><span class="go">    x = 10 # local
</span><span class="go">    return x+y
</span><span class="go">end
</span><span class="go">function foo()
</span><span class="go">    x = 2 # local
</span><span class="go">    return bar() + x # 12 + 2 (x is not modified)
</span><span class="go">end
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">foo</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="go">14 # as x is not modified anymore.
</span><span class="go">   # (x,y unchanged)
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Note that above subtlety does not pertain to type and macro definitions as they can only appear at the global scope. There are special scoping rules concerning the evaluation of default and keyword function arguments which are described in the <a href="@ref">Function section</a>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>An assignment introducing a variable used inside a function, type or macro definition need not come before its inner usage:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">f</span><span> </span><span class="o">=</span><span> </span><span class="n">y</span><span> </span><span class="o">-&gt;</span><span> </span><span class="n">x</span><span> </span><span class="o">+</span><span> </span><span class="n">y</span><span>
</span><span class="go">(::#1) (generic function with 1 method)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span>
</span><span class="go">ERROR: UndefVarError: x not defined
</span><span class="go"> in (::##1#2)(::Int64) at ./none:1
</span><span class="go"> ...
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span>
</span><span class="go">1
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span>
</span><span class="go">4
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This behavior may seem slightly odd for a normal variable, but allows for named functions – which are just normal variables holding function objects – to be used before they are defined. This allows functions to be defined in whatever order is intuitive and convenient, rather than forcing bottom up ordering or requiring forward declarations, as long as they are defined by the time they are actually called.  As an example, here is an inefficient, mutually recursive way to test if positive integers are even or odd:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">even(n) = n == 0 ? true  :  odd(n-1)
</span><span class="go">odd(n)  = n == 0 ? false : even(n-1)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">even</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span>
</span><span class="go">false
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">odd</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span>
</span><span class="go">true
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia provides built-in, efficient functions to test for oddness and evenness called <a href="../stdlib/numbers.html#Base.iseven"><code>iseven()</code></a> and <a href="../stdlib/numbers.html#Base.isodd"><code>isodd()</code></a> so the above definitions should only be taken as examples.</p><a id="Hard-vs.-Soft-Local-Scope-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Hard vs. Soft Local Scope</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Blocks which introduce a soft local scope, such as loops, are generally used to manipulate the variables in their parent scope. Thus their default is to fully access all variables in their parent scope.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Conversely, the code inside blocks which introduce a hard local scope (function, type, and macro definitions) can be executed at any place in a program.  Remotely changing the state of global variables in other modules should be done with care and thus this is an opt-in feature requiring the <code>global</code> keyword.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The reason to allow <em>modifying local</em> variables of parent scopes in nested functions is to allow constructing <a href="https://en.wikipedia.org/wiki/Closure_%28computer_programming%29">closures</a> which have a private state, for instance the <code>state</code> variable in the following example:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">let
</span><span class="go">    state = 0
</span><span class="go">    global counter
</span><span class="go">    counter() = state += 1
</span><span class="go">end
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">counter</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="go">1
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">counter</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="go">2
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>See also the closures in the examples in the next two sections.</p><a id="Let-Blocks-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Let Blocks</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Unlike assignments to local variables, <code>let</code> statements allocate new variable bindings each time they run. An assignment modifies an existing value location, and <code>let</code> creates new locations. This difference is usually not important, and is only detectable in the case of variables that outlive their scope via closures. The <code>let</code> syntax accepts a comma-separated series of assignments and variable names:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">let</span><span> </span><span class="n">var1</span><span> </span><span class="o">=</span><span> </span><span class="n">value1</span><span class="p">,</span><span> </span><span class="n">var2</span><span class="p">,</span><span> </span><span class="n">var3</span><span> </span><span class="o">=</span><span> </span><span class="n">value3</span><span>
</span><span>    </span><span class="n">code</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The assignments are evaluated in order, with each right-hand side evaluated in the scope before the new variable on the left-hand side has been introduced. Therefore it makes sense to write something like <code>let x = x</code> since the two <code>x</code> variables are distinct and have separate storage. Here is an example where the behavior of <code>let</code> is needed:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">Fs = Array{Any}(2)
</span><span class="go">i = 1
</span><span class="go">while i &lt;= 2
</span><span class="go">    Fs[i] = ()-&gt;i
</span><span class="go">    i += 1
</span><span class="go">end
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Fs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="go">3
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Fs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="go">3
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Here we create and store two closures that return variable <code>i</code>. However, it is always the same variable <code>i</code>, so the two closures behave identically. We can use <code>let</code> to create a new binding for <code>i</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">Fs = Array{Any}(2)
</span><span class="go">i = 1
</span><span class="go">while i &lt;= 2
</span><span class="go">    let i = i
</span><span class="go">    end
</span><span class="go">    i += 1
</span><span class="go">end
</span><span class="go">
</span><span></span><span class="gt">
        Fs[i] = ()-&gt;i
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Fs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="go">1
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Fs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="go">2
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Since the <code>begin</code> construct does not introduce a new scope, it can be useful to use a zero-argument <code>let</code> to just introduce a new scope block without creating any new bindings:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="k">let</span><span>
</span><span class="gt">
           local x = 1
</span><span></span><span class="gt">
           let
</span><span></span><span class="gt">
               local x = 2
</span><span></span><span class="gt">
           end
</span><span></span><span class="gt">
           x
</span><span></span><span class="gt">
       end
</span><span></span><span class="go">1
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Since <code>let</code> introduces a new scope block, the inner local <code>x</code> is a different variable than the outer local <code>x</code>.</p><a id="For-Loops-and-Comprehensions-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>For Loops and Comprehensions</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p><code>for</code> loops and <a href="@ref">comprehensions</a> have the following behavior: any new variables introduced in their body scopes are freshly allocated for each loop iteration.  This is in contrast to <code>while</code> loops which reuse the variables for all iterations. Therefore these constructs are similar to <code>while</code> loops with <code>let</code> blocks inside:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">Fs = Array{Any}(2)
</span><span class="go">for i = 1:2
</span><span class="go">    Fs[i] = ()-&gt;i
</span><span class="go">end
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Fs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="go">1
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Fs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="go">2
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p><code>for</code> loops will reuse existing variables for its iteration variable:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">i</span><span> </span><span class="o">=</span><span> </span><span class="mi">0</span><span>
</span><span class="k">for</span><span> </span><span class="n">i</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span>
</span><span class="k">end</span><span>
</span><span class="n">i</span><span>  </span><span class="c"># here equal to 3</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>However, comprehensions do not do this, and always freshly allocate their iteration variables:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">x</span><span> </span><span class="o">=</span><span> </span><span class="mi">0</span><span>
</span><span class="p">[</span><span> </span><span class="n">x</span><span> </span><span class="k">for</span><span> </span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span> </span><span class="p">]</span><span>
</span><span class="n">x</span><span>  </span><span class="c"># here still equal to 0</span><span>
</span></code></pre><a id="Constants-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Constants</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A common use of variables is giving names to specific, unchanging values. Such variables are only assigned once. This intent can be conveyed to the compiler using the <code>const</code> keyword:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="kd">const</span><span> </span><span class="n">e</span><span>  </span><span class="o">=</span><span> </span><span class="mf">2.71828182845904523536</span><span>
</span><span class="kd">const</span><span> </span><span class="nb">pi</span><span> </span><span class="o">=</span><span> </span><span class="mf">3.14159265358979323846</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The <code>const</code> declaration is allowed on both global and local variables, but is especially useful for globals. It is difficult for the compiler to optimize code involving global variables, since their values (or even their types) might change at almost any time. If a global variable will not change, adding a <code>const</code> declaration solves this performance problem.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Local constants are quite different. The compiler is able to determine automatically when a local variable is constant, so local constant declarations are not necessary for performance purposes.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Special top-level assignments, such as those performed by the <code>function</code> and <code>type</code> keywords, are constant by default.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Note that <code>const</code> only affects the variable binding; the variable may be bound to a mutable object (such as an array), and that object may still be modified.</p><footer><hr/><a class="previous" href="unicode-input.html"><span class="direction">Previous</span><span class="title">Unicode Input</span></a><a class="next" href="variables.html"><span class="direction">Next</span><span class="title">Variables</span></a></footer></article></body></html>
