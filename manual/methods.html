<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documenter.jl</title><link href="../normalize.css" rel="stylesheet" type="text/css"/><link href="../style.css" rel="stylesheet" type="text/css"/><link href="../highlight.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="../require.js" data-main="../documenter.js"></script><script src="../search-index.js"></script></head><body><nav class="toc"><a href="http://julialang.org/"><img class="logo" src="http://docs.julialang.org/en/release-0.4/_static/julia-logo.svg" alt="\$pkgname.jl logo"/></a><h1>$pkgname.jl</h1><input type="text" placeholder="Search docs"/><ul><li><a class="toctext" href="../index.html">Overview</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/guide.html">Guide</a></li><li><a class="toctext" href="../man/examples.html">Examples</a></li><li><a class="toctext" href="../man/syntax.html">Syntax</a></li><li><a class="toctext" href="../man/doctests.html">Doctests</a></li><li><a class="toctext" href="../man/hosting.html">Hosting Documentation</a></li><li><a class="toctext" href="../man/latex.html"><span>$\LaTeX$</span> syntax</a></li><li><a class="toctext" href="../man/internals.html">Package Internals</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../lib/public.html">Public Documentation</a></li><li><a class="toctext" href="../lib/internals.html">Internal Documentation</a></li></ul></li><li><span class="toctext">Dynamic pages</span><ul><li><a class="toctext" href="../dynamic/code.html">Code examples</a></li><li><a class="toctext" href="../dynamic/admonitions.html">Admonitions &amp; Co</a></li><li><a class="toctext" href="../dynamic/styles.html">Demonstrating <em>styles</em> of MD elements</a></li><li><a class="toctext" href="../dynamic/bugs.html">Some existing bugs</a></li></ul></li><li><span class="toctext">JuliaDocs - Manual</span><ul><li><a class="toctext" href="arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="constructors.html">Constructors</a></li><li><a class="toctext" href="control-flow.html">Control Flow</a></li><li><a class="toctext" href="conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="dates.html">Date and DateTime</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="functions.html">Functions</a></li><li><a class="toctext" href="getting-started.html">Getting Started</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="index.html">The Julia Manual</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="introduction.html">Introduction</a></li><li><a class="toctext" href="linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramming</a></li><li class="current"><a class="toctext" href="methods.html">Methods</a><ul class="internal"><li><a class="toctext" href="#Defining-Methods-1">Defining Methods</a></li><li><a class="toctext" href="#Method-Ambiguities-1">Method Ambiguities</a></li><li><a class="toctext" href="#Parametric-Methods-1">Parametric Methods</a></li><li><a class="toctext" href="#Parametrically-constrained-Varargs-methods-1">Parametrically-constrained Varargs methods</a></li><li><a class="toctext" href="#Note-on-Optional-and-keyword-Arguments-1">Note on Optional and keyword Arguments</a></li><li><a class="toctext" href="#Function-like-objects-1">Function-like objects</a></li><li><a class="toctext" href="#Empty-generic-functions-1">Empty generic functions</a></li></ul></li><li><a class="toctext" href="modules.html">Modules</a></li><li><a class="toctext" href="networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="packages.html">Packages</a></li><li><a class="toctext" href="parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="style-guide.html">Style Guide</a></li><li><a class="toctext" href="types.html">Types</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li><li><a class="toctext" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="variables.html">Variables</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li></ul></li><li><span class="toctext">JuliaDocs - Standard Libary</span><ul><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/c.html">C Interface</a></li><li><a class="toctext" href="../stdlib/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../stdlib/constants.html">Constants</a></li><li><a class="toctext" href="../stdlib/dates.html">Dates and Time</a></li><li><a class="toctext" href="../stdlib/file.html">Filesystem</a></li><li><a class="toctext" href="../stdlib/index.html">The Julia Standard Library</a></li><li><a class="toctext" href="../stdlib/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../stdlib/libc.html">C Standard Library</a></li><li><a class="toctext" href="../stdlib/libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/linalg.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/math.html">Mathematics</a></li><li><a class="toctext" href="../stdlib/numbers.html">Numbers</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="../stdlib/pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../stdlib/simd-types.html">SIMD Support</a></li><li><a class="toctext" href="../stdlib/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../stdlib/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../stdlib/strings.html">Strings</a></li><li><a class="toctext" href="../stdlib/test.html">Unit Testing</a></li></ul></li><li><span class="toctext">JuliaDocs - DevDocs</span><ul><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/C.html">Developing/debugging Julia&#39;s C code</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/julia.html">Documentation of Julia&#39;s Internals</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/promote-op.html">Operator-sensitive promotion</a></li><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>JuliaDocs - Manual</li><li><a href="methods.html">Methods</a></li></ul><a class="edit-page" href="https://github.com/"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><a id="Methods-1"></a><div class="mdnote debug">Base.Markdown.Header{1}</div><h1>Methods</h1><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Recall from <a href="@ref">Functions</a> that a function is an object that maps a tuple of arguments to a return value, or throws an exception if no appropriate value can be returned. It is common for the same conceptual function or operation to be implemented quite differently for different types of arguments: adding two integers is very different from adding two floating-point numbers, both of which are distinct from adding an integer to a floating-point number. Despite their implementation differences, these operations all fall under the general concept of &quot;addition&quot;. Accordingly, in Julia, these behaviors all belong to a single object: the <code>+</code> function.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>To facilitate using many different implementations of the same concept smoothly, functions need not be defined all at once, but can rather be defined piecewise by providing specific behaviors for certain combinations of argument types and counts. A definition of one possible behavior for a function is called a <em>method</em>. Thus far, we have presented only examples of functions defined with a single method, applicable to all types of arguments. However, the signatures of method definitions can be annotated to indicate the types of arguments in addition to their number, and more than a single method definition may be provided. When a function is applied to a particular tuple of arguments, the most specific method applicable to those arguments is applied. Thus, the overall behavior of a function is a patchwork of the behaviors of its various method definitions. If the patchwork is well designed, even though the implementations of the methods may be quite different, the outward behavior of the function will appear seamless and consistent.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The choice of which method to execute when a function is applied is called <em>dispatch</em>. Julia allows the dispatch process to choose which of a function&#39;s methods to call based on the number of arguments given, and on the types of all of the function&#39;s arguments. This is different than traditional object-oriented languages, where dispatch occurs based only on the first argument, which often has a special argument syntax, and is sometimes implied rather than explicitly written as an argument. <a href="#footnote-1">[1]</a> Using all of a function&#39;s arguments to choose which method should be invoked, rather than just the first, is known as <a href="https://en.wikipedia.org/wiki/Multiple_dispatch">multiple dispatch</a>. Multiple dispatch is particularly useful for mathematical code, where it makes little sense to artificially deem the operations to &quot;belong&quot; to one argument more than any of the others: does the addition operation in <code>x + y</code> belong to <code>x</code> any more than it does to <code>y</code>? The implementation of a mathematical operator generally depends on the types of all of its arguments. Even beyond mathematical operations, however, multiple dispatch ends up being a powerful and convenient paradigm for structuring and organizing programs.</p><div class="mdnote debug">Base.Markdown.Admonition</div><div class="admonition footnote"><div class="admonition-title">[1]</div><div class="admonition-text"><p>In C++ or Java, for example, in a method call like <code>obj.meth(arg1,arg2)</code>, the object obj &quot;receives&quot; the method call and is implicitly passed to the method via the <code>this</code> keyword, rather than as an explicit method argument. When the current <code>this</code> object is the receiver of a method call, it can be omitted altogether, writing just <code>meth(arg1,arg2)</code>, with <code>this</code> implied as the receiving object.</p></div></div><a id="Defining-Methods-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Defining Methods</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Until now, we have, in our examples, defined only functions with a single method having unconstrained argument types. Such functions behave just like they would in traditional dynamically typed languages. Nevertheless, we have used multiple dispatch and methods almost continually without being aware of it: all of Julia&#39;s standard functions and operators, like the aforementioned <code>+</code> function, have many methods defining their behavior over various possible combinations of argument type and count.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>When defining a function, one can optionally constrain the types of parameters it is applicable to, using the <code>::</code> type-assertion operator, introduced in the section on <a href="types.html#Composite-Types-1">Composite Types</a>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="kt">Float64</span><span class="p">,</span><span> </span><span class="n">y</span><span class="p">:</span><span class="p">:</span><span class="kt">Float64</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">2</span><span class="n">x</span><span> </span><span class="o">+</span><span> </span><span class="n">y</span><span class="p">;</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This function definition applies only to calls where <code>x</code> and <code>y</code> are both values of type <code>Float64</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">f</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span><span> </span><span class="mf">3.0</span><span class="p">)</span><span>
</span><span class="go">7.0
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Applying it to any other types of arguments will result in a <code>MethodError</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">f</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span><span> </span><span class="mi">3</span><span class="p">)</span><span>
</span><span class="go">ERROR: MethodError: no method matching f(::Float64, ::Int64)
</span><span class="go">Closest candidates are:
</span><span class="go">  f(::Float64, !Matched::Float64)
</span><span class="go"> ...
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">f</span><span class="p">(</span><span class="kt">Float32</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span><span class="p">,</span><span> </span><span class="mf">3.0</span><span class="p">)</span><span>
</span><span class="go">ERROR: MethodError: no method matching f(::Float32, ::Float64)
</span><span class="go">Closest candidates are:
</span><span class="go">  f(!Matched::Float64, ::Float64)
</span><span class="go"> ...
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">f</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span><span> </span><span class="s">&quot;</span><span class="s">3.0</span><span class="s">&quot;</span><span class="p">)</span><span>
</span><span class="go">ERROR: MethodError: no method matching f(::Float64, ::String)
</span><span class="go">Closest candidates are:
</span><span class="go">  f(::Float64, !Matched::Float64)
</span><span class="go"> ...
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">f</span><span class="p">(</span><span class="s">&quot;</span><span class="s">2.0</span><span class="s">&quot;</span><span class="p">,</span><span> </span><span class="s">&quot;</span><span class="s">3.0</span><span class="s">&quot;</span><span class="p">)</span><span>
</span><span class="go">ERROR: MethodError: no method matching f(::String, ::String)
</span><span class="go"> ...
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>As you can see, the arguments must be precisely of type <code>Float64</code>. Other numeric types, such as integers or 32-bit floating-point values, are not automatically converted to 64-bit floating-point, nor are strings parsed as numbers. Because <code>Float64</code> is a concrete type and concrete types cannot be subclassed in Julia, such a definition can only be applied to arguments that are exactly of type <code>Float64</code>. It may often be useful, however, to write more general methods where the declared parameter types are abstract:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">Number</span><span class="p">,</span><span> </span><span class="n">y</span><span class="p">:</span><span class="p">:</span><span class="n">Number</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">2</span><span class="n">x</span><span> </span><span class="o">-</span><span> </span><span class="n">y</span><span class="p">;</span><span>
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">f</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span><span> </span><span class="mi">3</span><span class="p">)</span><span>
</span><span class="go">1.0
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This method definition applies to any pair of arguments that are instances of <code>Number</code>. They need not be of the same type, so long as they are each numeric values. The problem of handling disparate numeric types is delegated to the arithmetic operations in the expression <code>2x - y</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>To define a function with multiple methods, one simply defines the function multiple times, with different numbers and types of arguments. The first method definition for a function creates the function object, and subsequent method definitions add new methods to the existing function object. The most specific method definition matching the number and types of the arguments will be executed when the function is applied. Thus, the two method definitions above, taken together, define the behavior for <code>f</code> over all pairs of instances of the abstract type <code>Number</code> – but with a different behavior specific to pairs of <code>Float64</code> values. If one of the arguments is a 64-bit float but the other one is not, then the <code>f(Float64,Float64)</code> method cannot be called and the more general <code>f(Number,Number)</code> method must be used:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">f</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span><span> </span><span class="mf">3.0</span><span class="p">)</span><span>
</span><span class="go">7.0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span> </span><span class="mf">3.0</span><span class="p">)</span><span>
</span><span class="go">1.0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">f</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span><span> </span><span class="mi">3</span><span class="p">)</span><span>
</span><span class="go">1.0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span> </span><span class="mi">3</span><span class="p">)</span><span>
</span><span class="go">1
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The <code>2x + y</code> definition is only used in the first case, while the <code>2x - y</code> definition is used in the others. No automatic casting or conversion of function arguments is ever performed: all conversion in Julia is non-magical and completely explicit. <a href="conversion-and-promotion.html#Conversion-and-Promotion-1">Conversion and Promotion</a>, however, shows how clever application of sufficiently advanced technology can be indistinguishable from magic. <a href="#citation-Clarke61">[Clarke61]</a></p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For non-numeric values, and for fewer or more than two arguments, the function <code>f</code> remains undefined, and applying it will still result in a <code>MethodError</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">f</span><span class="p">(</span><span class="s">&quot;</span><span class="s">foo</span><span class="s">&quot;</span><span class="p">,</span><span> </span><span class="mi">3</span><span class="p">)</span><span>
</span><span class="go">ERROR: MethodError: no method matching f(::String, ::Int64)
</span><span class="go">Closest candidates are:
</span><span class="go">  f(!Matched::Number, ::Number)
</span><span class="go"> ...
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">f</span><span class="p">(</span><span class="p">)</span><span>
</span><span class="go">ERROR: MethodError: no method matching f()
</span><span class="go">Closest candidates are:
</span><span class="go">  f(!Matched::Float64, !Matched::Float64)
</span><span class="go">  f(!Matched::Number, !Matched::Number)
</span><span class="go"> ...
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>You can easily see which methods exist for a function by entering the function object itself in an interactive session:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">f</span><span>
</span><span class="go">f (generic function with 2 methods)
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This output tells us that <code>f</code> is a function object with two methods. To find out what the signatures of those methods are, use the <code>methods()</code> function:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">methods</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span>
</span><span class="go"># 2 methods for generic function &quot;f&quot;:
</span><span class="go">f(x::Float64, y::Float64) at none:1
</span><span class="go">f(x::Number, y::Number) at none:1
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>which shows that <code>f</code> has two methods, one taking two <code>Float64</code> arguments and one taking arguments of type <code>Number</code>. It also indicates the file and line number where the methods were defined: because these methods were defined at the REPL, we get the apparent line number <code>none:1</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In the absence of a type declaration with <code>::</code>, the type of a method parameter is <code>Any</code> by default, meaning that it is unconstrained since all values in Julia are instances of the abstract type <code>Any</code>. Thus, we can define a catch-all method for <code>f</code> like so:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">println</span><span class="p">(</span><span class="s">&quot;</span><span class="s">Whoa there, Nelly.</span><span class="s">&quot;</span><span class="p">)</span><span class="p">;</span><span>
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">f</span><span class="p">(</span><span class="s">&quot;</span><span class="s">foo</span><span class="s">&quot;</span><span class="p">,</span><span> </span><span class="mi">1</span><span class="p">)</span><span>
</span><span class="go">Whoa there, Nelly.
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This catch-all is less specific than any other possible method definition for a pair of parameter values, so it is only be called on pairs of arguments to which no other method definition applies.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Although it seems a simple concept, multiple dispatch on the types of values is perhaps the single most powerful and central feature of the Julia language. Core operations typically have dozens of methods:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go"> julia&gt; methods(+)
</span><span class="go"> # 166 methods for generic function &quot;+&quot;:
</span><span class="go"> +(a::Float16, b::Float16) at float16.jl:136
</span><span class="go"> +(x::Float32, y::Float32) at float.jl:206
</span><span class="go"> +(x::Float64, y::Float64) at float.jl:207
</span><span class="go"> +(x::Bool, z::Complex{Bool}) at complex.jl:126
</span><span class="go"> +(x::Bool, y::Bool) at bool.jl:48
</span><span class="go"> +(x::Bool) at bool.jl:45
</span><span class="go"> +{T&lt;:AbstractFloat}(x::Bool, y::T) at bool.jl:55
</span><span class="go"> +(x::Bool, z::Complex) at complex.jl:133
</span><span class="go"> +(x::Bool, A::AbstractArray{Bool,N&lt;:Any}) at arraymath.jl:105
</span><span class="go"> +(x::Char, y::Integer) at char.jl:40
</span><span class="go"> +{T&lt;:Union{Int128,Int16,Int32,Int64,Int8,UInt128,UInt16,UInt32,UInt64,UInt8}}(x::T, y::T) at int.jl:32
</span><span class="go"> +(z::Complex, w::Complex) at complex.jl:115
</span><span class="go"> +(z::Complex, x::Bool) at complex.jl:134
</span><span class="go"> +(x::Real, z::Complex{Bool}) at complex.jl:140
</span><span class="go"> +(x::Real, z::Complex) at complex.jl:152
</span><span class="go"> +(z::Complex, x::Real) at complex.jl:153
</span><span class="go"> +(x::Rational, y::Rational) at rational.jl:179
</span><span class="go"> ...
</span><span class="go"> +(a, b, c, xs...) at operators.jl:119
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Multiple dispatch together with the flexible parametric type system give Julia its ability to abstractly express high-level algorithms decoupled from implementation details, yet generate efficient, specialized code to handle each case at run time.</p><a id="Method-Ambiguities-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Method Ambiguities</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>It is possible to define a set of function methods such that there is no unique most specific method applicable to some combinations of arguments:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="kt">Float64</span><span class="p">,</span><span> </span><span class="n">y</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">2</span><span class="n">x</span><span> </span><span class="o">+</span><span> </span><span class="n">y</span><span class="p">;</span><span>
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span> </span><span class="n">y</span><span class="p">:</span><span class="p">:</span><span class="kt">Float64</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">x</span><span> </span><span class="o">+</span><span> </span><span class="mi">2</span><span class="n">y</span><span class="p">;</span><span>
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">g</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span><span> </span><span class="mi">3</span><span class="p">)</span><span>
</span><span class="go">7.0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">g</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span> </span><span class="mf">3.0</span><span class="p">)</span><span>
</span><span class="go">8.0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">g</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span><span> </span><span class="mf">3.0</span><span class="p">)</span><span>
</span><span class="go">ERROR: MethodError: g(::Float64, ::Float64) is ambiguous. Candidates:
</span><span class="go">  g(x, y::Float64) at none:1
</span><span class="go">  g(x::Float64, y) at none:1
</span><span class="go"> ...
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Here the call <code>g(2.0, 3.0)</code> could be handled by either the <code>g(Float64, Any)</code> or the <code>g(Any, Float64)</code> method, and neither is more specific than the other. In such cases, Julia raises a <code>MethodError</code> rather than arbitrarily picking a method. You can avoid method ambiguities by specifying an appropriate method for the intersection case:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="kt">Float64</span><span class="p">,</span><span> </span><span class="n">y</span><span class="p">:</span><span class="p">:</span><span class="kt">Float64</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">2</span><span class="n">x</span><span> </span><span class="o">+</span><span> </span><span class="mi">2</span><span class="n">y</span><span class="p">;</span><span>
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="kt">Float64</span><span class="p">,</span><span> </span><span class="n">y</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="mi">2</span><span class="n">x</span><span> </span><span class="o">+</span><span> </span><span class="n">y</span><span class="p">;</span><span>
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span> </span><span class="n">y</span><span class="p">:</span><span class="p">:</span><span class="kt">Float64</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">x</span><span> </span><span class="o">+</span><span> </span><span class="mi">2</span><span class="n">y</span><span class="p">;</span><span>
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">g</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span><span> </span><span class="mi">3</span><span class="p">)</span><span>
</span><span class="go">7.0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">g</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span> </span><span class="mf">3.0</span><span class="p">)</span><span>
</span><span class="go">8.0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">g</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span><span> </span><span class="mf">3.0</span><span class="p">)</span><span>
</span><span class="go">10.0
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>It is recommended that the disambiguating method be defined first, since otherwise the ambiguity exists, if transiently, until the more specific method is defined.</p><a id="Parametric-Methods-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Parametric Methods</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Method definitions can optionally have type parameters immediately after the method name and before the parameter tuple:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">same_type</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span class="p">,</span><span> </span><span class="n">y</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">true</span><span class="p">;</span><span>
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">same_type</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">false</span><span class="p">;</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The first method applies whenever both arguments are of the same concrete type, regardless of what type that is, while the second method acts as a catch-all, covering all other cases. Thus, overall, this defines a boolean function that checks whether its two arguments are of the same type:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">same_type</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span> </span><span class="mi">2</span><span class="p">)</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">same_type</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span> </span><span class="mf">2.0</span><span class="p">)</span><span>
</span><span class="go">false
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">same_type</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span> </span><span class="mf">2.0</span><span class="p">)</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">same_type</span><span class="p">(</span><span class="s">&quot;</span><span class="s">foo</span><span class="s">&quot;</span><span class="p">,</span><span> </span><span class="mf">2.0</span><span class="p">)</span><span>
</span><span class="go">false
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">same_type</span><span class="p">(</span><span class="s">&quot;</span><span class="s">foo</span><span class="s">&quot;</span><span class="p">,</span><span> </span><span class="s">&quot;</span><span class="s">bar</span><span class="s">&quot;</span><span class="p">)</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">same_type</span><span class="p">(</span><span class="kt">Int32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">,</span><span> </span><span class="kt">Int64</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">false
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This kind of definition of function behavior by dispatch is quite common – idiomatic, even – in Julia. Method type parameters are not restricted to being used as the types of parameters: they can be used anywhere a value would be in the signature of the function or body of the function. Here&#39;s an example where the method type parameter <code>T</code> is used as the type parameter to the parametric type <code>Vector{T}</code> in the method signature:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">myappend</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">(</span><span class="n">v</span><span class="p">:</span><span class="p">:</span><span class="n">Vector</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="p">,</span><span> </span><span class="n">x</span><span class="p">]</span><span>
</span><span class="go">myappend (generic function with 1 method)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">myappend</span><span class="p">(</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span>
</span><span class="go">4-element Array{Int64,1}:
</span><span class="go"> 1
</span><span class="go"> 2
</span><span class="go"> 3
</span><span class="go"> 4
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">myappend</span><span class="p">(</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="p">,</span><span class="mf">2.5</span><span class="p">)</span><span>
</span><span class="go">ERROR: MethodError: no method matching myappend(::Array{Int64,1}, ::Float64)
</span><span class="go">Closest candidates are:
</span><span class="go">  myappend{T}(::Array{T,1}, !Matched::T)
</span><span class="go"> ...
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">myappend</span><span class="p">(</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">3.0</span><span class="p">]</span><span class="p">,</span><span class="mf">4.0</span><span class="p">)</span><span>
</span><span class="go">4-element Array{Float64,1}:
</span><span class="go"> 1.0
</span><span class="go"> 2.0
</span><span class="go"> 3.0
</span><span class="go"> 4.0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">myappend</span><span class="p">(</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">3.0</span><span class="p">]</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span>
</span><span class="go">ERROR: MethodError: no method matching myappend(::Array{Float64,1}, ::Int64)
</span><span class="go">Closest candidates are:
</span><span class="go">  myappend{T}(::Array{T,1}, !Matched::T)
</span><span class="go"> ...
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>As you can see, the type of the appended element must match the element type of the vector it is appended to, or else a <code>MethodError</code> is raised. In the following example, the method type parameter <code>T</code> is used as the return value:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">mytypeof</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">T</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">T</span><span>
</span><span class="go">mytypeof (generic function with 1 method)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">mytypeof</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span>
</span><span class="go">Int64
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">mytypeof</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span>
</span><span class="go">Float64
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Just as you can put subtype constraints on type parameters in type declarations (see <a href="types.html#Parametric-Types-1">Parametric Types</a>), you can also constrain type parameters of methods:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">same_type_numeric{T&lt;:Number}(x::T, y::T) = true
</span><span class="go">same_type_numeric(x::Number, y::Number) = false
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">same_type_numeric</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span> </span><span class="mi">2</span><span class="p">)</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">same_type_numeric</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span> </span><span class="mf">2.0</span><span class="p">)</span><span>
</span><span class="go">false
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">same_type_numeric</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span> </span><span class="mf">2.0</span><span class="p">)</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">same_type_numeric</span><span class="p">(</span><span class="s">&quot;</span><span class="s">foo</span><span class="s">&quot;</span><span class="p">,</span><span> </span><span class="mf">2.0</span><span class="p">)</span><span>
</span><span class="go">no method same_type_numeric(String,Float64)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">same_type_numeric</span><span class="p">(</span><span class="s">&quot;</span><span class="s">foo</span><span class="s">&quot;</span><span class="p">,</span><span> </span><span class="s">&quot;</span><span class="s">bar</span><span class="s">&quot;</span><span class="p">)</span><span>
</span><span class="go">no method same_type_numeric(String,String)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">same_type_numeric</span><span class="p">(</span><span class="kt">Int32</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">,</span><span> </span><span class="kt">Int64</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">false
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The <code>same_type_numeric</code> function behaves much like the <code>same_type</code> function defined above, but is only defined for pairs of numbers.</p><a id="Parametrically-constrained-Varargs-methods-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Parametrically-constrained Varargs methods</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Function parameters can also be used to constrain the number of arguments that may be supplied to a &quot;varargs&quot; function (<a href="functions.html#Varargs-Functions-1">Varargs Functions</a>).  The notation <code>Vararg{T,N}</code> is used to indicate such a constraint.  For example:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">bar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">Vararg</span><span class="p">{</span><span class="kt">Any</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="p">;</span><span>
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">bar</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span>
</span><span class="go">ERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64)
</span><span class="go">...
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">bar</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span>
</span><span class="go">(1,2,(3,4))
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">bar</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span><span>
</span><span class="go">ERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64, ::Int64, ::Int64)
</span><span class="go">...
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>More usefully, it is possible to constrain varargs methods by a parameter.  For example:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">getindex</span><span class="p">{</span><span class="n">T</span><span class="p">,</span><span class="n">N</span><span class="p">}</span><span class="p">(</span><span class="n">A</span><span class="p">:</span><span class="p">:</span><span class="n">AbstractArray</span><span class="p">{</span><span class="n">T</span><span class="p">,</span><span class="n">N</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">indexes</span><span class="p">:</span><span class="p">:</span><span class="n">Vararg</span><span class="p">{</span><span class="n">Number</span><span class="p">,</span><span class="n">N</span><span class="p">}</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>would be called only when the number of <code>indexes</code> matches the dimensionality of the array.</p><a id="Note-on-Optional-and-keyword-Arguments-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Note on Optional and keyword Arguments</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>As mentioned briefly in <a href="@ref">Functions</a>, optional arguments are implemented as syntax for multiple method definitions. For example, this definition:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">a</span><span class="o">+</span><span class="mi">2</span><span class="n">b</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>translates to the following three methods:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">a</span><span class="o">+</span><span class="mi">2</span><span class="n">b</span><span>
</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span>
</span><span class="n">f</span><span class="p">(</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This means that calling <code>f()</code> is equivalent to calling <code>f(1,2)</code>. In this case the result is <code>5</code>, because <code>f(1,2)</code> invokes the first method of <code>f</code> above. However, this need not always be the case. If you define a fourth method that is more specialized for integers:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="p">:</span><span class="kt">Int</span><span class="p">,</span><span class="n">b</span><span class="p">:</span><span class="p">:</span><span class="kt">Int</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">a</span><span class="o">-</span><span class="mi">2</span><span class="n">b</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>then the result of both <code>f()</code> and <code>f(1,2)</code> is <code>-3</code>. In other words, optional arguments are tied to a function, not to any specific method of that function. It depends on the types of the optional arguments which method is invoked. When optional arguments are defined in terms of a global variable, the type of the optional argument may even change at run-time.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Keyword arguments behave quite differently from ordinary positional arguments. In particular, they do not participate in method dispatch. Methods are dispatched based only on positional arguments, with keyword arguments processed after the matching method is identified.</p><a id="Function-like-objects-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Function-like objects</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Methods are associated with types, so it is possible to make any arbitrary Julia object &quot;callable&quot; by adding methods to its type. (Such &quot;callable&quot; objects are sometimes called &quot;functors.&quot;)</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For example, you can define a type that stores the coefficients of a polynomial, but behaves like a function evaluating the polynomial:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">immutable</span><span> </span><span class="n">Polynomial</span><span class="p">{</span><span class="n">R</span><span class="p">}</span><span>
</span><span>    </span><span class="n">coeffs</span><span class="p">:</span><span class="p">:</span><span class="n">Vector</span><span class="p">{</span><span class="n">R</span><span class="p">}</span><span>
</span><span class="k">end</span><span>
</span><span>
</span><span class="k">function</span><span class="nf"> </span><span class="o">(</span><span class="n">p</span><span class="p">:</span><span class="p">:</span><span class="n">Polynomial</span><span class="p">)</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span>
</span><span>    </span><span class="n">v</span><span> </span><span class="o">=</span><span> </span><span class="n">p</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="k">end</span><span class="p">]</span><span>
</span><span>    </span><span class="k">for</span><span> </span><span class="n">i</span><span> </span><span class="o">=</span><span> </span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">coeffs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span>
</span><span>        </span><span class="n">v</span><span> </span><span class="o">=</span><span> </span><span class="n">v</span><span class="o">*</span><span class="n">x</span><span> </span><span class="o">+</span><span> </span><span class="n">p</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span>    </span><span class="k">return</span><span> </span><span class="n">v</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Notice that the function is specified by type instead of by name. In the function body, <code>p</code> will refer to the object that was called. A <code>Polynomial</code> can be used as follows:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">p</span><span> </span><span class="o">=</span><span> </span><span class="n">Polynomial</span><span class="p">(</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">100</span><span class="p">]</span><span class="p">)</span><span>
</span><span class="go">Polynomial{Int64}([1,10,100])
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">p</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span>
</span><span class="go">931
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This mechanism is also the key to how type constructors and closures (inner functions that refer to their surrounding environment) work in Julia, discussed <a href="@ref">later in the manual</a>.</p><a id="Empty-generic-functions-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Empty generic functions</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Occasionally it is useful to introduce a generic function without yet adding methods. This can be used to separate interface definitions from implementations. It might also be done for the purpose of documentation or code readability. The syntax for this is an empty <code>function</code> block without a tuple of arguments:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">function</span><span class="nf"> </span><span class="nf">emptyfunc</span><span>
</span><span class="k">end</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Admonition</div><div class="admonition citation"><div class="admonition-title">[Clarke61]</div><div class="admonition-text"><p>Arthur C. Clarke, <em>Profiles of the Future</em> (1961): Clarke&#39;s Third Law.</p></div></div><footer><hr/><a class="previous" href="metaprogramming.html"><span class="direction">Previous</span><span class="title">Metaprogramming</span></a><a class="next" href="modules.html"><span class="direction">Next</span><span class="title">Modules</span></a></footer></article></body></html>
