<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documenter.jl</title><link href="../normalize.css" rel="stylesheet" type="text/css"/><link href="../style.css" rel="stylesheet" type="text/css"/><link href="../highlight.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="../require.js" data-main="../documenter.js"></script><script src="../search-index.js"></script></head><body><nav class="toc"><a href="http://julialang.org/"><img class="logo" src="http://docs.julialang.org/en/release-0.4/_static/julia-logo.svg" alt="\$pkgname.jl logo"/></a><h1>$pkgname.jl</h1><input type="text" placeholder="Search docs"/><ul><li><a class="toctext" href="../index.html">Overview</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/guide.html">Guide</a></li><li><a class="toctext" href="../man/examples.html">Examples</a></li><li><a class="toctext" href="../man/syntax.html">Syntax</a></li><li><a class="toctext" href="../man/doctests.html">Doctests</a></li><li><a class="toctext" href="../man/hosting.html">Hosting Documentation</a></li><li><a class="toctext" href="../man/latex.html"><span>$\LaTeX$</span> syntax</a></li><li><a class="toctext" href="../man/internals.html">Package Internals</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../lib/public.html">Public Documentation</a></li><li><a class="toctext" href="../lib/internals.html">Internal Documentation</a></li></ul></li><li><span class="toctext">Dynamic pages</span><ul><li><a class="toctext" href="../dynamic/code.html">Code examples</a></li><li><a class="toctext" href="../dynamic/admonitions.html">Admonitions &amp; Co</a></li><li><a class="toctext" href="../dynamic/styles.html">Demonstrating <em>styles</em> of MD elements</a></li><li><a class="toctext" href="../dynamic/bugs.html">Some existing bugs</a></li></ul></li><li><span class="toctext">JuliaDocs - Manual</span><ul><li><a class="toctext" href="arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="constructors.html">Constructors</a></li><li><a class="toctext" href="control-flow.html">Control Flow</a></li><li><a class="toctext" href="conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="dates.html">Date and DateTime</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li class="current"><a class="toctext" href="embedding.html">Embedding Julia</a><ul class="internal"><li><a class="toctext" href="#High-Level-Embedding-1">High-Level Embedding</a></li><li><a class="toctext" href="#Converting-Types-1">Converting Types</a></li><li><a class="toctext" href="#Calling-Julia-Functions-1">Calling Julia Functions</a></li><li><a class="toctext" href="#Memory-Management-1">Memory Management</a></li><li><a class="toctext" href="#Working-with-Arrays-1">Working with Arrays</a></li><li><a class="toctext" href="#Exceptions-1">Exceptions</a></li></ul></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="functions.html">Functions</a></li><li><a class="toctext" href="getting-started.html">Getting Started</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="index.html">The Julia Manual</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="introduction.html">Introduction</a></li><li><a class="toctext" href="linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="methods.html">Methods</a></li><li><a class="toctext" href="modules.html">Modules</a></li><li><a class="toctext" href="networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="packages.html">Packages</a></li><li><a class="toctext" href="parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="style-guide.html">Style Guide</a></li><li><a class="toctext" href="types.html">Types</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li><li><a class="toctext" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="variables.html">Variables</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li></ul></li><li><span class="toctext">JuliaDocs - Standard Libary</span><ul><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/c.html">C Interface</a></li><li><a class="toctext" href="../stdlib/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../stdlib/constants.html">Constants</a></li><li><a class="toctext" href="../stdlib/dates.html">Dates and Time</a></li><li><a class="toctext" href="../stdlib/file.html">Filesystem</a></li><li><a class="toctext" href="../stdlib/index.html">The Julia Standard Library</a></li><li><a class="toctext" href="../stdlib/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../stdlib/libc.html">C Standard Library</a></li><li><a class="toctext" href="../stdlib/libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/linalg.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/math.html">Mathematics</a></li><li><a class="toctext" href="../stdlib/numbers.html">Numbers</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="../stdlib/pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../stdlib/simd-types.html">SIMD Support</a></li><li><a class="toctext" href="../stdlib/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../stdlib/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../stdlib/strings.html">Strings</a></li><li><a class="toctext" href="../stdlib/test.html">Unit Testing</a></li></ul></li><li><span class="toctext">JuliaDocs - DevDocs</span><ul><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/C.html">Developing/debugging Julia&#39;s C code</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/julia.html">Documentation of Julia&#39;s Internals</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/promote-op.html">Operator-sensitive promotion</a></li><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>JuliaDocs - Manual</li><li><a href="embedding.html">Embedding Julia</a></li></ul><a class="edit-page" href="https://github.com/"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><a id="Embedding-Julia-1"></a><div class="mdnote debug">Base.Markdown.Header{1}</div><h1>Embedding Julia</h1><div class="mdnote debug">Base.Markdown.Paragraph</div><p>As we have seen in <a href="calling-c-and-fortran-code.html#Calling-C-and-Fortran-Code-1">Calling C and Fortran Code</a>, Julia has a simple and efficient way to call functions written in C. But there are situations where the opposite is needed: calling Julia function from C code. This can be used to integrate Julia code into a larger C/C++ project, without the need to rewrite everything in C/C++. Julia has a C API to make this possible. As almost all programming languages have some way to call C functions, the Julia C API can also be used to build further language bridges (e.g. calling Julia from Python or C#).</p><a id="High-Level-Embedding-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>High-Level Embedding</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>We start with a simple C program that initializes Julia and calls some Julia code:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">#include &lt;julia.h&gt;

int main(int argc, char *argv[])
{
    /* required: setup the Julia context */
    jl_init(NULL);

    /* run Julia commands */
    jl_eval_string(&quot;print(sqrt(2.0))&quot;);

    /* strongly recommended: notify Julia that the
         program is about to terminate. this allows
         Julia time to cleanup pending write requests
         and run all finalizers
    */
    jl_atexit_hook(0);
    return 0;
}</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In order to build this program you have to put the path to the Julia header into the include path and link against <code>libjulia</code>. For instance, when Julia is installed to <code>$JULIA_DIR</code>, one can compile the above test program <code>test.c</code> with <code>gcc</code> using:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">gcc -o test -fPIC -I$JULIA_DIR/include/julia -L$JULIA_DIR/lib test.c -ljulia $JULIA_DIR/lib/julia/libstdc++.so.6</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Then if the environment variable <code>JULIA_HOME</code> is set to <code>$JULIA_DIR/bin</code>, the output <code>test</code> program can be executed.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Alternatively, look at the <code>embedding.c</code> program in the Julia source tree in the <code>examples/</code> folder. The file <code>ui/repl.c</code> program is another simple example of how to set <code>jl_options</code> options while linking against <code>libjulia</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The first thing that has to be done before calling any other Julia C function is to initialize Julia. This is done by calling <code>jl_init</code>, which takes as argument a C string (<code>const char*</code>) to the location where Julia is installed. When the argument is <code>NULL</code>, Julia tries to determine the install location automatically.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The second statement in the test program evaluates a Julia statement using a call to <code>jl_eval_string</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Before the program terminates, it is strongly recommended to call <code>jl_atexit_hook</code>.  The above example program calls this before returning from <code>main</code>.</p><div class="mdnote debug">Base.Markdown.Admonition</div><div class="admonition note"><div class="admonition-title"></div><div class="admonition-text"><p>Currently, dynamically linking with the <code>libjulia</code> shared library requires passing the <code>RTLD_GLOBAL</code> option. In Python, this looks like:</p><code>&gt;&gt;&gt; julia=CDLL(&#39;./libjulia.dylib&#39;,RTLD_GLOBAL)
&gt;&gt;&gt; julia.jl_init.argtypes = [c_char_p]
&gt;&gt;&gt; julia.jl_init(&#39;.&#39;)
250593296</code></div></div><div class="mdnote debug">Base.Markdown.Admonition</div><div class="admonition note"><div class="admonition-title"></div><div class="admonition-text"><p>If the julia program needs to access symbols from the main executable, it may be necessary to add <code>-Wl,--export-dynamic</code> linker flag at compile time on Linux in addition to the ones generated by <code>julia-config.jl</code> described below. This is not necessary when compiling a shared library.</p></div></div><a id="Using-julia-config-to-automatically-determine-build-parameters-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Using julia-config to automatically determine build parameters</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The script <em>julia-config.jl</em> was created to aid in determining what build parameters are required by a program that uses embedded Julia.  This script uses the build parameters and system configuration of the particular Julia distribution it is invoked by to export the necessary compiler flags for an embedding program to interact with that distribution.  This script is located in the Julia shared data directory.</p><a id="Example-1"></a><div class="mdnote debug">Base.Markdown.Header{4}</div><h4>Example</h4><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Below is essentially the same as above with one small change; the argument to <code>jl_init</code> is now <strong>JULIA_INIT_DIR</strong> which is defined by <em>julia-config.jl</em>.:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">#include &lt;julia.h&gt;

int main(int argc, char *argv[])
{
   jl_init(JULIA_INIT_DIR);
   (void)jl_eval_string(&quot;println(sqrt(2.0))&quot;);
   jl_atexit_hook(0);
   return 0;
}</code></pre><a id="On-the-command-line-1"></a><div class="mdnote debug">Base.Markdown.Header{4}</div><h4>On the command line</h4><div class="mdnote debug">Base.Markdown.Paragraph</div><p>A simple use of this script is from the command line.  Assuming that <em>julia-config.jl</em> is located in <em>/usr/local/julia/share/julia</em>, it can be invoked on the command line directly and takes any combination of 3 flags:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">/usr/local/julia/share/julia/julia-config.jl
Usage: julia-config [--cflags|--ldflags|--ldlibs]</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If the above example source is saved in the file <em>embed_example.c</em>, then the following command will compile it into a running program on Linux and Windows (MSYS2 environment), or if on OS/X, then substitute <code>clang</code> for <code>gcc</code>.:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">/usr/local/julia/share/julia/julia-config.jl --cflags --ldflags --ldlibs | xargs gcc embed_example.c</code></pre><a id="Use-in-Makefiles-1"></a><div class="mdnote debug">Base.Markdown.Header{4}</div><h4>Use in Makefiles</h4><div class="mdnote debug">Base.Markdown.Paragraph</div><p>But in general, embedding projects will be more complicated than the above, and so the following allows general makefile support as well – assuming GNU make because of the use of the <strong>shell</strong> macro expansions.  Additionally, though many times <em>julia-config.jl</em> may be found in the directory <em>/usr/local</em>, this is not necessarily the case, but Julia can be used to locate <em>julia-config.jl</em> too, and the makefile can be used to take advantage of that.  The above example is extended to use a Makefile:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">JL_SHARE = $(shell julia -e &#39;print(joinpath(JULIA_HOME,Base.DATAROOTDIR,&quot;julia&quot;))&#39;)
CFLAGS   += $(shell $(JL_SHARE)/julia-config.jl --cflags)
CXXFLAGS += $(shell $(JL_SHARE)/julia-config.jl --cflags)
LDFLAGS  += $(shell $(JL_SHARE)/julia-config.jl --ldflags)
LDLIBS   += $(shell $(JL_SHARE)/julia-config.jl --ldlibs)

all: embed_example</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Now the build command is simply <strong>make</strong>.</p><a id="Converting-Types-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Converting Types</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Real applications will not just need to execute expressions, but also return their values to the host program. <code>jl_eval_string</code> returns a <code>jl_value_t*</code>, which is a pointer to a heap-allocated Julia object. Storing simple data types like <code>Float64</code> in this way is called <code>boxing</code>, and extracting the stored primitive data is called <code>unboxing</code>. Our improved sample program that calculates the square root of 2 in Julia and reads back the result in C looks as follows:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">jl_value_t *ret = jl_eval_string(&quot;sqrt(2.0)&quot;);

if (jl_is_float64(ret)) {
    double ret_unboxed = jl_unbox_float64(ret);
    printf(&quot;sqrt(2.0) in C: %e \n&quot;, ret_unboxed);
}</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In order to check whether <code>ret</code> is of a specific Julia type, we can use the <code>jl_is_...</code> functions. By typing <code>typeof(sqrt(2.0))</code> into the Julia shell we can see that the return type is <code>Float64</code> (<code>double</code> in C). To convert the boxed Julia value into a C double the <code>jl_unbox_float64</code> function is used in the above code snippet.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Corresponding <code>jl_box_...</code> functions are used to convert the other way:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">jl_value_t</span><span> </span><span class="o">*</span><span class="n">a</span><span> </span><span class="o">=</span><span> </span><span class="n">jl_box_float64</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span><span class="p">;</span><span>
</span><span class="n">jl_value_t</span><span> </span><span class="o">*</span><span class="n">b</span><span> </span><span class="o">=</span><span> </span><span class="n">jl_box_float32</span><span class="p">(</span><span class="mf">3.0</span><span class="n">f</span><span class="p">)</span><span class="p">;</span><span>
</span><span class="n">jl_value_t</span><span> </span><span class="o">*</span><span class="n">c</span><span> </span><span class="o">=</span><span> </span><span class="n">jl_box_int32</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>As we will see next, boxing is required to call Julia functions with specific arguments.</p><a id="Calling-Julia-Functions-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Calling Julia Functions</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>While <code>jl_eval_string</code> allows C to obtain the result of a Julia expression, it does not allow passing arguments computed in C to Julia. For this you will need to invoke Julia functions directly, using <code>jl_call</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">jl_function_t</span><span> </span><span class="o">*</span><span class="n">func</span><span> </span><span class="o">=</span><span> </span><span class="n">jl_get_function</span><span class="p">(</span><span class="n">jl_base_module</span><span class="p">,</span><span> </span><span class="s">&quot;</span><span class="s">sqrt</span><span class="s">&quot;</span><span class="p">)</span><span class="p">;</span><span>
</span><span class="n">jl_value_t</span><span> </span><span class="o">*</span><span class="n">argument</span><span> </span><span class="o">=</span><span> </span><span class="n">jl_box_float64</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span><span class="p">;</span><span>
</span><span class="n">jl_value_t</span><span> </span><span class="o">*</span><span class="n">ret</span><span> </span><span class="o">=</span><span> </span><span class="n">jl_call1</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span> </span><span class="n">argument</span><span class="p">)</span><span class="p">;</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In the first step, a handle to the Julia function <code>sqrt</code> is retrieved by calling <code>jl_get_function</code>. The first argument passed to <code>jl_get_function</code> is a pointer to the <code>Base</code> module in which <code>sqrt</code> is defined. Then, the double value is boxed using <code>jl_box_float64</code>. Finally, in the last step, the function is called using <code>jl_call1</code>. <code>jl_call0</code>, <code>jl_call2</code>, and <code>jl_call3</code> functions also exist, to conveniently handle different numbers of arguments. To pass more arguments, use <code>jl_call</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs)</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Its second argument <code>args</code> is an array of <code>jl_value_t*</code> arguments and <code>nargs</code> is the number of arguments.</p><a id="Memory-Management-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Memory Management</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>As we have seen, Julia objects are represented in C as pointers. This raises the question of who is responsible for freeing these objects.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Typically, Julia objects are freed by a garbage collector (GC), but the GC does not automatically know that we are holding a reference to a Julia value from C. This means the GC can free objects out from under you, rendering pointers invalid.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The GC can only run when Julia objects are allocated. Calls like <code>jl_box_float64</code> perform allocation, and allocation might also happen at any point in running Julia code. However, it is generally safe to use pointers in between <code>jl_...</code> calls. But in order to make sure that values can survive <code>jl_...</code> calls, we have to tell Julia that we hold a reference to a Julia value. This can be done using the <code>JL_GC_PUSH</code> macros:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">jl_value_t *ret = jl_eval_string(&quot;sqrt(2.0)&quot;);
JL_GC_PUSH1(&amp;ret);
// Do something with ret
JL_GC_POP();</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The <code>JL_GC_POP</code> call releases the references established by the previous <code>JL_GC_PUSH</code>. Note that <code>JL_GC_PUSH</code>  is working on the stack, so it must be exactly paired with a <code>JL_GC_POP</code> before the stack frame is destroyed.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Several Julia values can be pushed at once using the <code>JL_GC_PUSH2</code> , <code>JL_GC_PUSH3</code> , and <code>JL_GC_PUSH4</code> macros. To push an array of Julia values one can use the  <code>JL_GC_PUSHARGS</code> macro, which can be used as follows:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">jl_value_t **args;
JL_GC_PUSHARGS(args, 2); // args can now hold 2 `jl_value_t*` objects
args[0] = some_value;
args[1] = some_other_value;
// Do something with args (e.g. call jl_... functions)
JL_GC_POP();</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The garbage collector also operates under the assumption that it is aware of every old-generation object pointing to a young-generation one. Any time a pointer is updated breaking that assumption, it must be signaled to the collector with the <code>jl_gc_wb</code> (write barrier) function like so:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">jl_value_t *parent = some_old_value, *child = some_young_value;
((some_specific_type*)parent)-&gt;field = child;
jl_gc_wb(parent, child);</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>It is in general impossible to predict which values will be old at runtime, so the write barrier must be inserted after all explicit stores. One notable exception is if the <code>parent</code> object was just allocated and garbage collection was not run since then. Remember that most <code>jl_...</code> functions can sometimes invoke garbage collection.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The write barrier is also necessary for arrays of pointers when updating their data directly. For example:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">jl_array_t *some_array = ...; // e.g. a Vector{Any}
void **data = (void**)jl_array_data(some_array);
jl_value_t *some_value = ...;
data[0] = some_value;
jl_gc_wb(some_array, some_value);</code></pre><a id="Manipulating-the-Garbage-Collector-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Manipulating the Garbage Collector</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>There are some functions to control the GC. In normal use cases, these should not be necessary.</p><div class="mdnote debug">Base.Markdown.Table</div><table><tr><th>Function</th><th>Description</th></tr><tr><td><code>jl_gc_collect()</code></td><td>Force a GC run</td></tr><tr><td><code>jl_gc_enable(0)</code></td><td>Disable the GC, return previous state as int</td></tr><tr><td><code>jl_gc_enable(1)</code></td><td>Enable the GC,  return previous state as int</td></tr><tr><td><code>jl_gc_is_enabled()</code></td><td>Return current state as int</td></tr></table><a id="Working-with-Arrays-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Working with Arrays</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia and C can share array data without copying. The next example will show how this works.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia arrays are represented in C by the datatype <code>jl_array_t*</code>. Basically, <code>jl_array_t</code> is a struct that contains:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p>Information about the datatype</p></li><li><p>A pointer to the data block</p></li><li><p>Information about the sizes of the array</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>To keep things simple, we start with a 1D array. Creating an array containing Float64 elements of length 10 is done by:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">jl_value_t</span><span class="o">*</span><span> </span><span class="n">array_type</span><span> </span><span class="o">=</span><span> </span><span class="n">jl_apply_array_type</span><span class="p">(</span><span class="n">jl_float64_type</span><span class="p">,</span><span> </span><span class="mi">1</span><span class="p">)</span><span class="p">;</span><span>
</span><span class="n">jl_array_t</span><span class="o">*</span><span> </span><span class="n">x</span><span>          </span><span class="o">=</span><span> </span><span class="n">jl_alloc_array_1d</span><span class="p">(</span><span class="n">array_type</span><span class="p">,</span><span> </span><span class="mi">10</span><span class="p">)</span><span class="p">;</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Alternatively, if you have already allocated the array you can generate a thin wrapper around its data:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">double *existingArray = (double*)malloc(sizeof(double)*10);
jl_array_t *x = jl_ptr_to_array_1d(array_type, existingArray, 10, 0);</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The last argument is a boolean indicating whether Julia should take ownership of the data. If this argument is non-zero, the GC will call <code>free</code> on the data pointer when the array is no longer referenced.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In order to access the data of x, we can use <code>jl_array_data</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">double *xData = (double*)jl_array_data(x);</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Now we can fill the array:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">for(size_t i=0; i&lt;jl_array_len(x); i++)
    xData[i] = i;</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Now let us call a Julia function that performs an in-place operation on <code>x</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">jl_function_t *func  = jl_get_function(jl_base_module, &quot;reverse!&quot;);
jl_call1(func, (jl_value_t*)x);</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>By printing the array, one can verify that the elements of <code>x</code> are now reversed.</p><a id="Accessing-Returned-Arrays-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Accessing Returned Arrays</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If a Julia function returns an array, the return value of <code>jl_eval_string</code> and <code>jl_call</code> can be cast to a <code>jl_array_t*</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">jl_function_t *func  = jl_get_function(jl_base_module, &quot;reverse&quot;);
jl_array_t *y = (jl_array_t*)jl_call1(func, (jl_value_t*)x);</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Now the content of <code>y</code> can be accessed as before using <code>jl_array_data</code>. As always, be sure to keep a reference to the array while it is in use.</p><a id="Multidimensional-Arrays-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Multidimensional Arrays</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia&#39;s multidimensional arrays are stored in memory in column-major order. Here is some code that creates a 2D array and accesses its properties:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">// Create 2D array of float64 type
jl_value_t *array_type = jl_apply_array_type(jl_float64_type, 2);
jl_array_t *x  = jl_alloc_array_2d(array_type, 10, 5);

// Get array pointer
double *p = (double*)jl_array_data(x);
// Get number of dimensions
int ndims = jl_array_ndims(x);
// Get the size of the i-th dim
size_t size0 = jl_array_dim(x,0);
size_t size1 = jl_array_dim(x,1);

// Fill array with data
for(size_t i=0; i&lt;size1; i++)
    for(size_t j=0; j&lt;size0; j++)
        p[j + size0*i] = i + j;</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Notice that while Julia arrays use 1-based indexing, the C API uses 0-based indexing (for example in calling <code>jl_array_dim</code>) in order to read as idiomatic C code.</p><a id="Exceptions-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Exceptions</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia code can throw exceptions. For example, consider:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">jl_eval_string</span><span class="p">(</span><span class="s">&quot;</span><span class="s">this_function_does_not_exist()</span><span class="s">&quot;</span><span class="p">)</span><span class="p">;</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This call will appear to do nothing. However, it is possible to check whether an exception was thrown:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="k">if</span><span> </span><span class="p">(</span><span class="n">jl_exception_occurred</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span>
</span><span>    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="s">%s </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span> </span><span class="n">jl_typeof_str</span><span class="p">(</span><span class="n">jl_exception_occurred</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>If you are using the Julia C API from a language that supports exceptions (e.g. Python, C#, C++), it makes sense to wrap each call into <code>libjulia</code> with a function that checks whether an exception was thrown, and then rethrows the exception in the host language.</p><a id="Throwing-Julia-Exceptions-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Throwing Julia Exceptions</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>When writing Julia callable functions, it might be necessary to validate arguments and throw exceptions to indicate errors. A typical type check looks like:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">if (!jl_is_float64(val)) {
    jl_type_error(function_name, (jl_value_t*)jl_float64_type, val);
}</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>General exceptions can be raised using the functions:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="language-none">void jl_error(const char *str);
void jl_errorf(const char *fmt, ...);</code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p><code>jl_error</code> takes a C string, and <code>jl_errorf</code> is called like <code>printf</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">jl_errorf</span><span class="p">(</span><span class="s">&quot;</span><span class="s">argument x = %d is too large</span><span class="s">&quot;</span><span class="p">,</span><span> </span><span class="n">x</span><span class="p">)</span><span class="p">;</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>where in this example <code>x</code> is assumed to be an integer.</p><footer><hr/><a class="previous" href="documentation.html"><span class="direction">Previous</span><span class="title">Documentation</span></a><a class="next" href="faq.html"><span class="direction">Next</span><span class="title">Frequently Asked Questions</span></a></footer></article></body></html>
