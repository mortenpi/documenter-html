<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documenter.jl</title><link href="../normalize.css" rel="stylesheet" type="text/css"/><link href="../style.css" rel="stylesheet" type="text/css"/><link href="../highlight.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="../require.js" data-main="../documenter.js"></script><script src="../search-index.js"></script></head><body><nav class="toc"><a href="http://julialang.org/"><img class="logo" src="http://docs.julialang.org/en/release-0.4/_static/julia-logo.svg" alt="\$pkgname.jl logo"/></a><h1>$pkgname.jl</h1><input type="text" placeholder="Search docs"/><ul><li><a class="toctext" href="../index.html">Overview</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/guide.html">Guide</a></li><li><a class="toctext" href="../man/examples.html">Examples</a></li><li><a class="toctext" href="../man/syntax.html">Syntax</a></li><li><a class="toctext" href="../man/doctests.html">Doctests</a></li><li><a class="toctext" href="../man/hosting.html">Hosting Documentation</a></li><li><a class="toctext" href="../man/latex.html"><span>$\LaTeX$</span> syntax</a></li><li><a class="toctext" href="../man/internals.html">Package Internals</a></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../lib/public.html">Public Documentation</a></li><li><a class="toctext" href="../lib/internals.html">Internal Documentation</a></li></ul></li><li><span class="toctext">Dynamic pages</span><ul><li><a class="toctext" href="../dynamic/code.html">Code examples</a></li><li><a class="toctext" href="../dynamic/admonitions.html">Admonitions &amp; Co</a></li><li><a class="toctext" href="../dynamic/styles.html">Demonstrating <em>styles</em> of MD elements</a></li><li><a class="toctext" href="../dynamic/bugs.html">Some existing bugs</a></li></ul></li><li><span class="toctext">JuliaDocs - Manual</span><ul><li><a class="toctext" href="arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="constructors.html">Constructors</a></li><li><a class="toctext" href="control-flow.html">Control Flow</a></li><li class="current"><a class="toctext" href="conversion-and-promotion.html">Conversion and Promotion</a><ul class="internal"><li><a class="toctext" href="#Conversion-1">Conversion</a></li><li><a class="toctext" href="#Promotion-1">Promotion</a></li></ul></li><li><a class="toctext" href="dates.html">Date and DateTime</a></li><li><a class="toctext" href="documentation.html">Documentation</a></li><li><a class="toctext" href="embedding.html">Embedding Julia</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="functions.html">Functions</a></li><li><a class="toctext" href="getting-started.html">Getting Started</a></li><li><a class="toctext" href="handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="index.html">The Julia Manual</a></li><li><a class="toctext" href="integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="interfaces.html">Interfaces</a></li><li><a class="toctext" href="introduction.html">Introduction</a></li><li><a class="toctext" href="linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="methods.html">Methods</a></li><li><a class="toctext" href="modules.html">Modules</a></li><li><a class="toctext" href="networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="packages.html">Packages</a></li><li><a class="toctext" href="parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="profile.html">Profiling</a></li><li><a class="toctext" href="running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="strings.html">Strings</a></li><li><a class="toctext" href="style-guide.html">Style Guide</a></li><li><a class="toctext" href="types.html">Types</a></li><li><a class="toctext" href="unicode-input.html">Unicode Input</a></li><li><a class="toctext" href="variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="variables.html">Variables</a></li><li><a class="toctext" href="workflow-tips.html">Workflow Tips</a></li></ul></li><li><span class="toctext">JuliaDocs - Standard Libary</span><ul><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/c.html">C Interface</a></li><li><a class="toctext" href="../stdlib/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../stdlib/constants.html">Constants</a></li><li><a class="toctext" href="../stdlib/dates.html">Dates and Time</a></li><li><a class="toctext" href="../stdlib/file.html">Filesystem</a></li><li><a class="toctext" href="../stdlib/index.html">The Julia Standard Library</a></li><li><a class="toctext" href="../stdlib/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../stdlib/libc.html">C Standard Library</a></li><li><a class="toctext" href="../stdlib/libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/linalg.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/math.html">Mathematics</a></li><li><a class="toctext" href="../stdlib/numbers.html">Numbers</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="../stdlib/pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../stdlib/simd-types.html">SIMD Support</a></li><li><a class="toctext" href="../stdlib/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../stdlib/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../stdlib/strings.html">Strings</a></li><li><a class="toctext" href="../stdlib/test.html">Unit Testing</a></li></ul></li><li><span class="toctext">JuliaDocs - DevDocs</span><ul><li><a class="toctext" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/C.html">Developing/debugging Julia&#39;s C code</a></li><li><a class="toctext" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="toctext" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/julia.html">Documentation of Julia&#39;s Internals</a></li><li><a class="toctext" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/promote-op.html">Operator-sensitive promotion</a></li><li><a class="toctext" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><a class="toctext" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="toctext" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="toctext" href="../devdocs/types.html">More about types</a></li><li><a class="toctext" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>JuliaDocs - Manual</li><li><a href="conversion-and-promotion.html">Conversion and Promotion</a></li></ul><a class="edit-page" href="https://github.com/"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><a id="Conversion-and-Promotion-1"></a><div class="mdnote debug">Base.Markdown.Header{1}</div><h1>Conversion and Promotion</h1><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Julia has a system for promoting arguments of mathematical operators to a common type, which has been mentioned in various other sections, including <a href="integers-and-floating-point-numbers.html#Integers-and-Floating-Point-Numbers-1">Integers and Floating-Point Numbers</a>, <a href="mathematical-operations.html#Mathematical-Operations-and-Elementary-Functions-1">Mathematical Operations and Elementary Functions</a>, <a href="@ref">Types</a>, and <a href="methods.html#Methods-1">Methods</a>. In this section, we explain how this promotion system works, as well as how to extend it to new types and apply it to functions besides built-in mathematical operators. Traditionally, programming languages fall into two camps with respect to promotion of arithmetic arguments:</p><div class="mdnote debug">Base.Markdown.List</div><ul><li><p><strong>Automatic promotion for built-in arithmetic types and operators.</strong> In most languages, built-in numeric types, when used as operands to arithmetic operators with infix syntax, such as <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>, are automatically promoted to a common type to produce the expected results. C, Java, Perl, and Python, to name a few, all correctly compute the sum <code>1 + 1.5</code> as the floating-point value <code>2.5</code>, even though one of the operands to <code>+</code> is an integer. These systems are convenient and designed carefully enough that they are generally all-but-invisible to the programmer: hardly anyone consciously thinks of this promotion taking place when writing such an expression, but compilers and interpreters must perform conversion before addition since integers and floating-point values cannot be added as-is. Complex rules for such automatic conversions are thus inevitably part of specifications and implementations for such languages.</p></li><li><p><strong>No automatic promotion.</strong> This camp includes Ada and ML – very &quot;strict&quot; statically typed languages. In these languages, every conversion must be explicitly specified by the programmer. Thus, the example expression <code>1 + 1.5</code> would be a compilation error in both Ada and ML. Instead one must write <code>real(1) + 1.5</code>, explicitly converting the integer <code>1</code> to a floating-point value before performing addition. Explicit conversion everywhere is so inconvenient, however, that even Ada has some degree of automatic conversion: integer literals are promoted to the expected integer type automatically, and floating-point literals are similarly promoted to appropriate floating-point types.</p></li></ul><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In a sense, Julia falls into the &quot;no automatic promotion&quot; category: mathematical operators are just functions with special syntax, and the arguments of functions are never automatically converted. However, one may observe that applying mathematical operations to a wide variety of mixed argument types is just an extreme case of polymorphic multiple dispatch – something which Julia&#39;s dispatch and type systems are particularly well-suited to handle. &quot;Automatic&quot; promotion of mathematical operands simply emerges as a special application: Julia comes with pre-defined catch-all dispatch rules for mathematical operators, invoked when no specific implementation exists for some combination of operand types. These catch-all rules first promote all operands to a common type using user-definable promotion rules, and then invoke a specialized implementation of the operator in question for the resulting values, now of the same type. User-defined types can easily participate in this promotion system by defining methods for conversion to and from other types, and providing a handful of promotion rules defining what types they should promote to when mixed with other types.</p><a id="Conversion-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Conversion</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Conversion of values to various types is performed by the <code>convert</code> function. The <code>convert</code> function generally takes two arguments: the first is a type object while the second is a value to convert to that type; the returned value is the value converted to an instance of given type. The simplest way to understand this function is to see it in action:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">x</span><span> </span><span class="o">=</span><span> </span><span class="mi">12</span><span>
</span><span class="go">12
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span>
</span><span class="go">Int64
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">convert</span><span class="p">(</span><span class="n">UInt8</span><span class="p">,</span><span> </span><span class="n">x</span><span class="p">)</span><span>
</span><span class="go">0x0c
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span><span>
</span><span class="go">UInt8
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">convert</span><span class="p">(</span><span class="n">AbstractFloat</span><span class="p">,</span><span> </span><span class="n">x</span><span class="p">)</span><span>
</span><span class="go">12.0
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span><span>
</span><span class="go">Float64
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Conversion isn&#39;t always possible, in which case a no method error is thrown indicating that <code>convert</code> doesn&#39;t know how to perform the requested conversion:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">convert</span><span class="p">(</span><span class="n">AbstractFloat</span><span class="p">,</span><span> </span><span class="s">&quot;</span><span class="s">foo</span><span class="s">&quot;</span><span class="p">)</span><span>
</span><span class="go">ERROR: MethodError: Cannot `convert` an object of type String to an object of type AbstractFloat
</span><span class="go">This may have arisen from a call to the constructor AbstractFloat(...),
</span><span class="go">since type constructors fall back to convert methods.
</span><span class="go"> ...
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Some languages consider parsing strings as numbers or formatting numbers as strings to be conversions (many dynamic languages will even perform conversion for you automatically), however Julia does not: even though some strings can be parsed as numbers, most strings are not valid representations of numbers, and only a very limited subset of them are. Therefore in Julia the dedicated <code>parse()</code> function must be used to perform this operation, making it more explicit.</p><a id="Defining-New-Conversions-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Defining New Conversions</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>To define a new conversion, simply provide a new method for <code>convert()</code>. That&#39;s really all there is to it. For example, the method to convert a real number to a boolean is this:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="nb">convert</span><span class="p">(</span><span class="p">:</span><span class="p">:</span><span class="n">Type</span><span class="p">{</span><span class="kt">Bool</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">Real</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">x</span><span class="o">==</span><span class="mi">0</span><span> </span><span class="o">?</span><span> </span><span class="n">false</span><span> </span><span class="p">:</span><span> </span><span class="n">x</span><span class="o">==</span><span class="mi">1</span><span> </span><span class="o">?</span><span> </span><span class="n">true</span><span> </span><span class="p">:</span><span> </span><span class="nb">throw</span><span class="p">(</span><span class="n">InexactError</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The type of the first argument of this method is a <a href="@ref">singleton type</a>, <code>Type{Bool}</code>, the only instance of which is <code>Bool</code>. Thus, this method is only invoked when the first argument is the type value <code>Bool</code>. Notice the syntax used for the first argument: the argument name is omitted prior to the <code>::</code> symbol, and only the type is given.  This is the syntax in Julia for a function argument whose type is specified but whose value is never used in the function body.  In this example, since the type is a singleton, there would never be any reason to use its value within the body. When invoked, the method determines whether a numeric value is true or false as a boolean, by comparing it to one and zero:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">convert</span><span class="p">(</span><span class="kt">Bool</span><span class="p">,</span><span> </span><span class="mi">1</span><span class="p">)</span><span>
</span><span class="go">true
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">convert</span><span class="p">(</span><span class="kt">Bool</span><span class="p">,</span><span> </span><span class="mi">0</span><span class="p">)</span><span>
</span><span class="go">false
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">convert</span><span class="p">(</span><span class="kt">Bool</span><span class="p">,</span><span> </span><span class="mi">1</span><span class="nb">im</span><span class="p">)</span><span>
</span><span class="go">ERROR: InexactError()
</span><span class="go"> in convert(::Type{Bool}, ::Complex{Int64}) at ./complex.jl:23
</span><span class="go"> ...
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">convert</span><span class="p">(</span><span class="kt">Bool</span><span class="p">,</span><span> </span><span class="mi">0</span><span class="nb">im</span><span class="p">)</span><span>
</span><span class="go">false
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The method signatures for conversion methods are often quite a bit more involved than this example, especially for parametric types. The example above is meant to be pedagogical, and is not the actual Julia behaviour. This is the actual implementation in Julia:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span class="go">convert{T&lt;:Real}(::Type{T}, z::Complex) = (imag(z)==0 ? convert(T,real(z)) :
</span><span class="go">
</span><span></span><span class="gt">
                                           throw(InexactError()))
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">convert</span><span class="p">(</span><span class="kt">Bool</span><span class="p">,</span><span> </span><span class="mi">1</span><span class="nb">im</span><span class="p">)</span><span>
</span><span class="go">ERROR: InexactError()
</span><span class="go"> in convert(::Type{Bool}, ::Complex{Int64}) at ./complex.jl:18
</span><span class="go"> ...
</span></code></pre><a id="Case-Study:-Rational-Conversions-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Case Study: Rational Conversions</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>To continue our case study of Julia&#39;s <code>Rational</code> type, here are the conversions declared in <a href="https://github.com/JuliaLang/julia/blob/master/base/rational.jl">rational.jl</a>, right after the declaration of the type and its constructors:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="nb">convert</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Integer</span><span class="p">}</span><span class="p">(</span><span class="p">:</span><span class="p">:</span><span class="n">Type</span><span class="p">{</span><span class="n">Rational</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">Rational</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">Rational</span><span class="p">(</span><span class="nb">convert</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">x</span><span class="o">.</span><span class="n">num</span><span class="p">)</span><span class="p">,</span><span class="nb">convert</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">x</span><span class="o">.</span><span class="n">den</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="nb">convert</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Integer</span><span class="p">}</span><span class="p">(</span><span class="p">:</span><span class="p">:</span><span class="n">Type</span><span class="p">{</span><span class="n">Rational</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">Integer</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">Rational</span><span class="p">(</span><span class="nb">convert</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="p">,</span><span> </span><span class="nb">convert</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="p">)</span><span>
</span><span>
</span><span class="k">function</span><span class="nf"> </span><span class="nf">convert</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Integer</span><span class="p">}</span><span class="p">(</span><span class="p">:</span><span class="p">:</span><span class="n">Type</span><span class="p">{</span><span class="n">Rational</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">AbstractFloat</span><span class="p">,</span><span> </span><span class="n">tol</span><span class="p">:</span><span class="p">:</span><span class="n">Real</span><span class="p">)</span><span>
</span><span>    </span><span class="k">if</span><span> </span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="p">;</span><span> </span><span class="k">return</span><span> </span><span class="n">zero</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="o">/</span><span class="o">/</span><span class="n">zero</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="p">;</span><span> </span><span class="k">end</span><span>
</span><span>    </span><span class="k">if</span><span> </span><span class="n">isinf</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="p">;</span><span> </span><span class="k">return</span><span> </span><span class="n">sign</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="o">/</span><span class="n">zero</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="p">;</span><span> </span><span class="k">end</span><span>
</span><span>    </span><span class="n">y</span><span> </span><span class="o">=</span><span> </span><span class="n">x</span><span>
</span><span>    </span><span class="n">a</span><span> </span><span class="o">=</span><span> </span><span class="n">d</span><span> </span><span class="o">=</span><span> </span><span class="n">one</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span>
</span><span>    </span><span class="n">b</span><span> </span><span class="o">=</span><span> </span><span class="n">c</span><span> </span><span class="o">=</span><span> </span><span class="n">zero</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span>
</span><span>    </span><span class="k">while</span><span> </span><span class="n">true</span><span>
</span><span>        </span><span class="n">f</span><span> </span><span class="o">=</span><span> </span><span class="nb">convert</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">round</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="p">)</span><span class="p">;</span><span> </span><span class="n">y</span><span> </span><span class="o">-</span><span class="o">=</span><span> </span><span class="n">f</span><span>
</span><span>        </span><span class="n">a</span><span class="p">,</span><span> </span><span class="n">b</span><span class="p">,</span><span> </span><span class="n">c</span><span class="p">,</span><span> </span><span class="n">d</span><span> </span><span class="o">=</span><span> </span><span class="n">f</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="n">c</span><span class="p">,</span><span> </span><span class="n">f</span><span class="o">*</span><span class="n">b</span><span class="o">+</span><span class="n">d</span><span class="p">,</span><span> </span><span class="n">a</span><span class="p">,</span><span> </span><span class="n">b</span><span>
</span><span>        </span><span class="k">if</span><span> </span><span class="n">y</span><span> </span><span class="o">==</span><span> </span><span class="mi">0</span><span> </span><span class="o">||</span><span> </span><span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span> </span><span class="o">&lt;=</span><span> </span><span class="n">tol</span><span>
</span><span>            </span><span class="k">return</span><span> </span><span class="n">a</span><span class="o">/</span><span class="o">/</span><span class="n">b</span><span>
</span><span>        </span><span class="k">end</span><span>
</span><span>        </span><span class="n">y</span><span> </span><span class="o">=</span><span> </span><span class="mi">1</span><span class="o">/</span><span class="n">y</span><span>
</span><span>    </span><span class="k">end</span><span>
</span><span class="k">end</span><span>
</span><span class="nb">convert</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Integer</span><span class="p">}</span><span class="p">(</span><span class="n">rt</span><span class="p">:</span><span class="p">:</span><span class="n">Type</span><span class="p">{</span><span class="n">Rational</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">AbstractFloat</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="nb">convert</span><span class="p">(</span><span class="n">rt</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="nb">eps</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="p">)</span><span>
</span><span>
</span><span class="nb">convert</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">AbstractFloat</span><span class="p">}</span><span class="p">(</span><span class="p">:</span><span class="p">:</span><span class="n">Type</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">Rational</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="nb">convert</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">x</span><span class="o">.</span><span class="n">num</span><span class="p">)</span><span class="o">/</span><span class="nb">convert</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">x</span><span class="o">.</span><span class="n">den</span><span class="p">)</span><span>
</span><span class="nb">convert</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Integer</span><span class="p">}</span><span class="p">(</span><span class="p">:</span><span class="p">:</span><span class="n">Type</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">,</span><span> </span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">Rational</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">div</span><span class="p">(</span><span class="nb">convert</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">x</span><span class="o">.</span><span class="n">num</span><span class="p">)</span><span class="p">,</span><span class="nb">convert</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">x</span><span class="o">.</span><span class="n">den</span><span class="p">)</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The initial four convert methods provide conversions to rational types. The first method converts one type of rational to another type of rational by converting the numerator and denominator to the appropriate integer type. The second method does the same conversion for integers by taking the denominator to be 1. The third method implements a standard algorithm for approximating a floating-point number by a ratio of integers to within a given tolerance, and the fourth method applies it, using machine epsilon at the given value as the threshold. In general, one should have <code>a//b == convert(Rational{Int64}, a/b)</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The last two convert methods provide conversions from rational types to floating-point and integer types. To convert to floating point, one simply converts both numerator and denominator to that floating point type and then divides. To convert to integer, one can use the <code>div</code> operator for truncated integer division (rounded towards zero).</p><a id="Promotion-1"></a><div class="mdnote debug">Base.Markdown.Header{2}</div><h2>Promotion</h2><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Promotion refers to converting values of mixed types to a single common type. Although it is not strictly necessary, it is generally implied that the common type to which the values are converted can faithfully represent all of the original values. In this sense, the term &quot;promotion&quot; is appropriate since the values are converted to a &quot;greater&quot; type – i.e. one which can represent all of the input values in a single common type. It is important, however, not to confuse this with object-oriented (structural) super-typing, or Julia&#39;s notion of abstract super-types: promotion has nothing to do with the type hierarchy, and everything to do with converting between alternate representations. For instance, although every <code>Int32</code> value can also be represented as a <code>Float64</code> value, <code>Int32</code> is not a subtype of <code>Float64</code>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Promotion to a common &quot;greater&quot; type is performed in Julia by the <code>promote</code> function, which takes any number of arguments, and returns a tuple of the same number of values, converted to a common type, or throws an exception if promotion is not possible. The most common use case for promotion is to convert numeric arguments to a common type:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">promote</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span> </span><span class="mf">2.5</span><span class="p">)</span><span>
</span><span class="go">(1.0,2.5)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">promote</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span> </span><span class="mf">2.5</span><span class="p">,</span><span> </span><span class="mi">3</span><span class="p">)</span><span>
</span><span class="go">(1.0,2.5,3.0)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">promote</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span> </span><span class="mi">3</span><span class="o">/</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span><span>
</span><span class="go">(2//1,3//4)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">promote</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span> </span><span class="mf">2.5</span><span class="p">,</span><span> </span><span class="mi">3</span><span class="p">,</span><span> </span><span class="mi">3</span><span class="o">/</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span><span>
</span><span class="go">(1.0,2.5,3.0,0.75)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">promote</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span><span> </span><span class="nb">im</span><span class="p">)</span><span>
</span><span class="go">(1.5 + 0.0im,0.0 + 1.0im)
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">promote</span><span class="p">(</span><span class="mi">1</span><span> </span><span class="o">+</span><span> </span><span class="mi">2</span><span class="nb">im</span><span class="p">,</span><span> </span><span class="mi">3</span><span class="o">/</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span><span>
</span><span class="go">(1//1 + 2//1*im,3//4 + 0//1*im)
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Floating-point values are promoted to the largest of the floating-point argument types. Integer values are promoted to the larger of either the native machine word size or the largest integer argument type. Mixtures of integers and floating-point values are promoted to a floating-point type big enough to hold all the values. Integers mixed with rationals are promoted to rationals. Rationals mixed with floats are promoted to floats. Complex values mixed with real values are promoted to the appropriate kind of complex value.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>That is really all there is to using promotions. The rest is just a matter of clever application, the most typical &quot;clever&quot; application being the definition of catch-all methods for numeric operations like the arithmetic operators <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code>. Here are some of the catch-all method definitions given in <a href="https://github.com/JuliaLang/julia/blob/master/base/promotion.jl">promotion.jl</a>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="o">+</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">Number</span><span class="p">,</span><span> </span><span class="n">y</span><span class="p">:</span><span class="p">:</span><span class="n">Number</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="o">+</span><span class="p">(</span><span class="nb">promote</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="p">)</span><span>
</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">Number</span><span class="p">,</span><span> </span><span class="n">y</span><span class="p">:</span><span class="p">:</span><span class="n">Number</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="o">-</span><span class="p">(</span><span class="nb">promote</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="p">)</span><span>
</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">Number</span><span class="p">,</span><span> </span><span class="n">y</span><span class="p">:</span><span class="p">:</span><span class="n">Number</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="o">*</span><span class="p">(</span><span class="nb">promote</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="p">)</span><span>
</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="p">:</span><span class="n">Number</span><span class="p">,</span><span> </span><span class="n">y</span><span class="p">:</span><span class="p">:</span><span class="n">Number</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="o">/</span><span class="p">(</span><span class="nb">promote</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In certain cases, the result type also depends on the operator; how to handle such scenarios is described <a href="@ref">elsewhere</a>.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>These method definitions say that in the absence of more specific rules for adding, subtracting, multiplying and dividing pairs of numeric values, promote the values to a common type and then try again. That&#39;s all there is to it: nowhere else does one ever need to worry about promotion to a common numeric type for arithmetic operations – it just happens automatically. There are definitions of catch-all promotion methods for a number of other arithmetic and mathematical functions in <a href="https://github.com/JuliaLang/julia/blob/master/base/promotion.jl">promotion.jl</a>, but beyond that, there are hardly any calls to <code>promote</code> required in the Julia standard library. The most common usages of <code>promote</code> occur in outer constructors methods, provided for convenience, to allow constructor calls with mixed types to delegate to an inner type with fields promoted to an appropriate common type. For example, recall that <a href="https://github.com/JuliaLang/julia/blob/master/base/rational.jl">rational.jl</a> provides the following outer constructor method:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">Rational</span><span class="p">(</span><span class="n">n</span><span class="p">:</span><span class="p">:</span><span class="n">Integer</span><span class="p">,</span><span> </span><span class="n">d</span><span class="p">:</span><span class="p">:</span><span class="n">Integer</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">Rational</span><span class="p">(</span><span class="nb">promote</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This allows calls like the following to work:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="n">Rational</span><span class="p">(</span><span class="kt">Int8</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span><span class="p">,</span><span class="kt">Int32</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span><span class="p">)</span><span>
</span><span class="go">-3//1
</span><span class="go">
</span><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span><span>
</span><span class="go">Rational{Int32}
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>For most user-defined types, it is better practice to require programmers to supply the expected types to constructor functions explicitly, but sometimes, especially for numeric problems, it can be convenient to do promotion automatically.</p><a id="Defining-Promotion-Rules-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Defining Promotion Rules</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Although one could, in principle, define methods for the <code>promote</code> function directly, this would require many redundant definitions for all possible permutations of argument types. Instead, the behavior of <code>promote</code> is defined in terms of an auxiliary function called <code>promote_rule</code>, which one can provide methods for. The <code>promote_rule</code> function takes a pair of type objects and returns another type object, such that instances of the argument types will be promoted to the returned type. Thus, by defining the rule:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">promote_rule</span><span class="p">(</span><span class="p">:</span><span class="p">:</span><span class="n">Type</span><span class="p">{</span><span class="kt">Float64</span><span class="p">}</span><span class="p">,</span><span> </span><span class="p">:</span><span class="p">:</span><span class="n">Type</span><span class="p">{</span><span class="kt">Float32</span><span class="p">}</span><span> </span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="kt">Float64</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>one declares that when 64-bit and 32-bit floating-point values are promoted together, they should be promoted to 64-bit floating-point. The promotion type does not need to be one of the argument types, however; the following promotion rules both occur in Julia&#39;s standard library:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">promote_rule</span><span class="p">(</span><span class="p">:</span><span class="p">:</span><span class="n">Type</span><span class="p">{</span><span class="n">UInt8</span><span class="p">}</span><span class="p">,</span><span> </span><span class="p">:</span><span class="p">:</span><span class="n">Type</span><span class="p">{</span><span class="kt">Int8</span><span class="p">}</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="kt">Int</span><span>
</span><span class="n">promote_rule</span><span class="p">(</span><span class="p">:</span><span class="p">:</span><span class="n">Type</span><span class="p">{</span><span class="n">BigInt</span><span class="p">}</span><span class="p">,</span><span> </span><span class="p">:</span><span class="p">:</span><span class="n">Type</span><span class="p">{</span><span class="kt">Int8</span><span class="p">}</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">BigInt</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>In the latter case, the result type is <code>BigInt</code> since <code>BigInt</code> is the only type large enough to hold integers for arbitrary-precision integer arithmetic.  Also note that one does not need to define both <code>promote_rule(::Type{A}, ::Type{B})</code> and <code>promote_rule(::Type{B}, ::Type{A})</code> – the symmetry is implied by the way <code>promote_rule</code> is used in the promotion process.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The <code>promote_rule</code> function is used as a building block to define a second function called <code>promote_type</code>, which, given any number of type objects, returns the common type to which those values, as arguments to <code>promote</code> should be promoted. Thus, if one wants to know, in absence of actual values, what type a collection of values of certain types would promote to, one can use <code>promote_type</code>:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-jlcon"><span></span><span class="gp">julia&gt;</span><span> </span><span class="nb">promote_type</span><span class="p">(</span><span class="kt">Int8</span><span class="p">,</span><span> </span><span class="n">UInt16</span><span class="p">)</span><span>
</span><span class="go">Int64
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Internally, <code>promote_type</code> is used inside of <code>promote</code> to determine what type argument values should be converted to for promotion. It can, however, be useful in its own right. The curious reader can read the code in <a href="https://github.com/JuliaLang/julia/blob/master/base/promotion.jl">promotion.jl</a>, which defines the complete promotion mechanism in about 35 lines.</p><a id="Case-Study:-Rational-Promotions-1"></a><div class="mdnote debug">Base.Markdown.Header{3}</div><h3>Case Study: Rational Promotions</h3><div class="mdnote debug">Base.Markdown.Paragraph</div><p>Finally, we finish off our ongoing case study of Julia&#39;s rational number type, which makes relatively sophisticated use of the promotion mechanism with the following promotion rules:</p><div class="mdnote debug">Base.Markdown.Code</div><pre><code class="highlight language-julia"><span class="n">promote_rule</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Integer</span><span class="p">}</span><span class="p">(</span><span class="p">:</span><span class="p">:</span><span class="n">Type</span><span class="p">{</span><span class="n">Rational</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">}</span><span class="p">,</span><span> </span><span class="p">:</span><span class="p">:</span><span class="n">Type</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">Rational</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span>
</span><span class="n">promote_rule</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Integer</span><span class="p">,</span><span class="n">S</span><span class="o">&lt;:</span><span class="n">Integer</span><span class="p">}</span><span class="p">(</span><span class="p">:</span><span class="p">:</span><span class="n">Type</span><span class="p">{</span><span class="n">Rational</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">}</span><span class="p">,</span><span> </span><span class="p">:</span><span class="p">:</span><span class="n">Type</span><span class="p">{</span><span class="n">S</span><span class="p">}</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">Rational</span><span class="p">{</span><span class="nb">promote_type</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">S</span><span class="p">)</span><span class="p">}</span><span>
</span><span class="n">promote_rule</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Integer</span><span class="p">,</span><span class="n">S</span><span class="o">&lt;:</span><span class="n">Integer</span><span class="p">}</span><span class="p">(</span><span class="p">:</span><span class="p">:</span><span class="n">Type</span><span class="p">{</span><span class="n">Rational</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">}</span><span class="p">,</span><span> </span><span class="p">:</span><span class="p">:</span><span class="n">Type</span><span class="p">{</span><span class="n">Rational</span><span class="p">{</span><span class="n">S</span><span class="p">}</span><span class="p">}</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="n">Rational</span><span class="p">{</span><span class="nb">promote_type</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">S</span><span class="p">)</span><span class="p">}</span><span>
</span><span class="n">promote_rule</span><span class="p">{</span><span class="n">T</span><span class="o">&lt;:</span><span class="n">Integer</span><span class="p">,</span><span class="n">S</span><span class="o">&lt;:</span><span class="n">AbstractFloat</span><span class="p">}</span><span class="p">(</span><span class="p">:</span><span class="p">:</span><span class="n">Type</span><span class="p">{</span><span class="n">Rational</span><span class="p">{</span><span class="n">T</span><span class="p">}</span><span class="p">}</span><span class="p">,</span><span> </span><span class="p">:</span><span class="p">:</span><span class="n">Type</span><span class="p">{</span><span class="n">S</span><span class="p">}</span><span class="p">)</span><span> </span><span class="o">=</span><span> </span><span class="nb">promote_type</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">S</span><span class="p">)</span><span>
</span></code></pre><div class="mdnote debug">Base.Markdown.Paragraph</div><p>The first rule asserts that promotion of a rational number with its own numerator/denominator type, simply promotes to itself. The second rule says that promoting a rational number with any other integer type promotes to a rational type whose numerator/denominator type is the result of promotion of its numerator/denominator type with the other integer type. The third rule applies the same logic to two different types of rational numbers, resulting in a rational of the promotion of their respective numerator/denominator types. The fourth and final rule dictates that promoting a rational with a float results in the same type as promoting the numerator/denominator type with the float.</p><div class="mdnote debug">Base.Markdown.Paragraph</div><p>This small handful of promotion rules, together with the <a href="@ref">conversion methods discussed above</a>, are sufficient to make rational numbers interoperate completely naturally with all of Julia&#39;s other numeric types – integers, floating-point numbers, and complex numbers. By providing appropriate conversion methods and promotion rules in the same manner, any user-defined numeric type can interoperate just as naturally with Julia&#39;s predefined numerics.</p><footer><hr/><a class="previous" href="control-flow.html"><span class="direction">Previous</span><span class="title">Control Flow</span></a><a class="next" href="dates.html"><span class="direction">Next</span><span class="title">Date and DateTime</span></a></footer></article></body></html>
